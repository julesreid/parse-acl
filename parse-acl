#!/usr/bin/env python

"""
Script to find address ranges within a Cisco ACL

The idea is to find all ACLs which apply to a certain host or
network range.

To do:

* Implement ASA ACLs using the following keywords:
    object network
    object service
    object-group network
    object-group protocol
    object-group service
    access-list
* Match more than the first IP address on a line (only the first IP
  address on a line is tested -- all others are ignored).
* Match ranges (correctly accounting for overlaps, either in whole or part)
"""

import sys
import re
import socket
import struct
import getopt
import logging
from typing import Optional, NamedTuple

# Set some types used for holding data
#
IP = int
# For use when 3.9 is available
#PrefixLength = Annotated[int, ValueRange(0, 32)]
PrefixLength = int

class Subnet(NamedTuple):
    """Represent an IP address or subnet, with prefix length"""
    ip: IP
    prefix: PrefixLength = 32
    def __repr__(self) -> str:
        return 'Subnet(' + subnettoip(self) + ')'

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: Subnet
    ge: PrefixLength
    le: PrefixLength

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/(\d+)
    )?
'''

PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

NETWORK_OBJECT_RE = r'''
    \b
    network-object
    [ ]
'''

NETWORK_OBJECT_HOST_RE = r'''
    ^
    [ ]*
    (?:
    ''' + NETWORK_OBJECT_RE + '''
    )?
    host
    [ ]
    (''' + IP_ADDR + r''')
'''

NETWORK_OBJECT_NETWORK_RE = r'''
    ^
    [ ]*
    ''' + NETWORK_OBJECT_RE + '''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

ROUTE_RE = r'''
    ^
    [ ]*
    route
    [ ]
    \S+
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    \S+
    $
'''

### ACL matching

# Match the header of a standard or extended ACL
ACL_HEADER = (r'^(?:ip\ access-list\ (?:standard|extended)'
              r'|object(?:-group)?\ network)\ (\S+)')

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

STANDARD_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+(any|(''' + IP_ADDR + r')(?:\s+(' + IP_ADDR + r'''))?)
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

EXTENDED_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

EXTENDED_ASA_ACL_RE = r'''
    access-list
    [ ]
    \S+
    [ ]
    extended
    [ ]
    (permit|deny)
    [ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    [ ]
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' \
        + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' \
        + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

EXTENDED_IGNORE_RE = (r'(?:(?:access-list\ \d+)?\ (?:dynamic|evaluate|remark)'
                      r'\ |\s+description\ |\s+port-object\ |\s+group-object)')

### IP address utility functions

def iptoint(ip: str) -> IP:
    """Convert an IP address as a string into the internal IP format"""
    result: IP = struct.unpack("!I", socket.inet_aton(ip))[0]
    return result

def inttoip(int_: IP) -> str:
    """Convert the internal IP format into an IP address as a string"""
    return socket.inet_ntoa(struct.pack("!I", int_))

def iptosubnet(ip: str) -> Subnet:
    """Convert a string with an IP address and prefix into the internal
    Subnet format"""

    parts = ip.split('/')
    if len(parts) == 1:
        mask = 32
    elif len(parts) == 2:
        mask = int(parts[1])
    else:
        raise SyntaxError('subnet must have zero or one slashes')
    ip = parts[0]

    ipaddr_bin = iptoint(ip)
    return Subnet(ip=ipaddr_bin, prefix=mask)

def subnettoip(subnet: Subnet) -> str:
    """Convert the internal Subnet format into a string with an IP address
    and prefix"""
    return inttoip(subnet.ip) + '/' + str(subnet.prefix)

def maskof(length: PrefixLength) -> IP:
    """Given a prefix length, return the internal representation IP subnet
    mask.  This mask can be used in bitwise operations with an IP address."""
    return (-1 << (32 - length)) & 0xffffffff

def wildtonetmask(wild: str) -> IP:
    """Convert a wildcard mask as a string into the internal IP format
    of a net mask"""
    wildmask = iptoint(wild)
    netmask = (~wildmask) & 0xffffffff
    return netmask

def netmasktoprefix(mask: IP) -> PrefixLength:
    """Given an internal representation of a subnet mask, return the
    corresponding prefix length."""
    prefix = 32

    # Change netmask to a wildcard so that all of the 1s are on the right.
    # Can't use wildtonetmask here since mask is not a string.
    mask = (~mask) & 0xffffffff
    while mask > 0:
        mask >>= 1
        prefix -= 1
    return prefix

### IP subnet matching

def match_subnet(subnet1: Subnet, subnet2: Subnet,
                 minlen: PrefixLength, maxlen: PrefixLength) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    def subnet_test(addr1: IP, addr2: IP, prefixlen: PrefixLength) -> bool:
        """Test two IPv4 addresses, ADDR1 and ADDR2, for equality when
        normalized to a common prefix length PREFIXLEN."""
        mask = maskof(prefixlen)
        return (addr1 & mask) == (addr2 & mask)

    len1 = subnet1.prefix
    len2 = subnet2.prefix
    containmentp = subnet_test(subnet1.ip, subnet2.ip, min(len1, len2))
    return containmentp and minlen <= len1 <= maxlen

def containment(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Return True if subnet1 is a subnet of subnet2 or vice versa"""
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefix)

def is_contained_in(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, 32)

def matches_exact(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if subnet1 and subnet2 are identical, with the same IP
    and prefix length"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, subnet2.prefix)

def match_subnet_prefixrange(subnet: Subnet, prefix: PrefixRange) -> bool:
    """Test if subnet falls within the subset or superset given
    by the prefix range prefix"""
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Parsing

# XXX redefine to make more sense (e.g., "host" only is used in extended
# acls but not in standard acls)
def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: str, usewild: bool = True) -> Subnet:
    """Given the parts of a regex matching an ACL in the text,
    convert it to a subnet.  If usewild is set, reverse the bits of
    the re_mask variable.  The regexes that are used in the matching
    are EXTENDED_ACL_RE, EXTENDED_ASA_ACL_RE, and STANDARD_ACL_RE."""
    if re_range.startswith('host '):
        assert re_host is not None
        net = iptoint(re_host)
        mask = 32
    elif re_range in ("any", "any4"):
        net, mask = iptosubnet("0.0.0.0/0")
    else:
        net = iptoint(re_net)
        if usewild:
            mask = netmasktoprefix(wildtonetmask(re_mask))
        else:
            mask = netmasktoprefix(iptoint(re_mask))
    return Subnet(ip=net, prefix=mask)

# LEN: undefined GE: undefined LE: undefined   ge=32,  le=32
# LEN: undefined GE: undefined LE: defined     ge=32,  le=LE
# LEN: undefined GE: defined   LE: defined     ge=GE,  le=LE
# LEN: undefined GE: defined   LE: undefined   ge=GE,  le=32

# LEN: defined   GE: defined   LE: undefined   ge=GE,  le=32
# LEN: defined   GE: defined   LE: defined     ge=GE,  le=LE
# LEN: defined   GE: undefined LE: defined     ge=LEN, le=LE
# LEN: defined   GE: undefined LE: undefined   ge=LEN, le=LEN
def normalize_prefix_lengths(ip: int,
                             length: Optional[int],
                             ge: Optional[int],
                             le: Optional[int]) -> PrefixRange:
    """Fill in the parts of a prefix range using default or derived
    values if those parts are None"""
    if length is None:
        length = 32
    if le is None:
        if ge is None:
            ge = le = length
        else:
            le = 32
    elif ge is None:
        ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(Subnet(ip=ip, prefix=length), ge, le)

def safe_int(intstr: Optional[str]) -> Optional[int]:
    """Convert a string to an integer, or None is intstr is None"""
    if intstr is None:
        return None
    return int(intstr)

def parse_prefix_list(arg: str) -> PrefixRange:
    """Given the string representation of a prefix range, convert it
    to a PrefixRange object"""
    re_match = re.match(PREFIX_RE, arg, re.X)
    if not re_match:
        raise SyntaxError('invalid prefix range')
    ip = iptoint(re_match.group(1))
    length = safe_int(re_match.group(2))
    ge = safe_int(re_match.group(3))
    le = safe_int(re_match.group(4))
    return normalize_prefix_lengths(ip, length, ge, le)

def normalized(subnet: Subnet) -> bool:
    """Return True if host portion of the IP address is all zeroes."""
    ip = subnet.ip
    length = subnet.prefix
    return ip & maskof(length) == ip

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    """Conduct various tests on the arguments, used for testing the script"""
    ipaddr1 = iptosubnet(ipaddr1_str)
    ipaddr2 = iptosubnet(ipaddr2_str)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

### Main program

def main() -> None:
    """Main routine"""

    # Match anything by default
    srcmatch = dstmatch = PrefixRange(iptosubnet("0.0.0.0/0"), ge=0, le=32)
    reverse = False
    test = False
    log_level = logging.INFO

    try:
        opts, parseargs = getopt.getopt(sys.argv[1:], 's:d:xvt')
    except getopt.GetoptError as err:
        print("%s: %s" % (sys.argv[0], err))
        sys.exit(1)
    #print "DEBUG:", opts, parseargs
    for opt, arg in opts:
        if opt == '-s':
            # Handle source address
            srcmatch = parse_prefix_list(arg)
            if not normalized(srcmatch.subnet):
                print("warning: src ip not normalized (%s)"
                      % subnettoip(srcmatch.subnet))
        elif opt == '-d':
            # Handle destination address
            dstmatch = parse_prefix_list(arg)
            if not normalized(dstmatch.subnet):
                print("warning: dst ip not normalized (%s)"
                      % subnettoip(dstmatch.subnet))
        elif opt == '-x':
            reverse = True
        elif opt == '-v':
            log_level = logging.DEBUG
        elif opt == '-t':
            test = True

    # Set up logging
    logging.basicConfig(level=log_level,
                        format="%(levelname)s:%(funcName)s:"
                               "%(lineno)d:%(message)s")

    if test:
        if len(parseargs) != 4:
            raise ValueError('not right number of arguments for -t')
        testsubnets(ipaddr1_str=parseargs[0], ipaddr2_str=parseargs[1],
                    minlen_str=parseargs[2], maxlen_str=parseargs[3])
        sys.exit(0)

    if reverse:
        srcmatch, dstmatch = dstmatch, srcmatch

    logging.debug("srcmatch = %r", srcmatch)
    logging.debug("dstmatch = %r", dstmatch)

    last_acl_name = None
    current_acl_name = None
    current_acl_line = None
    for line_num, line in enumerate(sys.stdin, start=1):
        line = line.rstrip('\r\n')
        logging.debug("linenum = %r, line = %r", line_num, line)
        re_match = re.match(ACL_HEADER, line, re.X)
        if re_match:
            logging.debug("ACL_HEADER = %r", re_match.groups())
            current_acl_name = line
            current_acl_line = line_num
            continue
        re_match = re.match(EXTENDED_IGNORE_RE, line, re.X)
        if re_match:
            assert re_match.groups() == ()
            logging.debug("got EXTENDED_IGNORE_RE")
            # Do not reset current_acl_name (parser is in middle of object)
            continue
        re_match = re.match(ROUTE_RE, line, re.X)
        if re_match:
            logging.debug("got ROUTE_RE = %r", re_match.groups())
            srcarg = re_match.group(1)
            msk = re_match.group(2)
            dstarg = re_match.group(3)
            logging.debug("route %r %r %r", srcarg, msk, dstarg)

        re_match = re.match(EXTENDED_ACL_RE, line, re.X)
        if re_match:
            logging.debug("EXTENDED_ACL_RE = %r", re_match.groups())
            wildcard = True
        else:
            re_match = re.match(EXTENDED_ASA_ACL_RE, line, re.X)
            if re_match:
                logging.debug("EXTENDED_ASA_ACL_RE = %r", re_match.groups())
                wildcard = False
        if re_match:
            # XXX needs to work when both -s and -d specified (logical or)
            # XXX needs error checking
            # XXX $7 and $12 are source or destination ports (if any)
            logging.debug("wildcard = %r", wildcard)
            src = range_to_net(re_match.group(3), re_match.group(4),
                               re_match.group(5), re_match.group(6),
                               usewild=wildcard)
            logging.debug("src = %r", src)
            dst_range = re_match.group(8)
            if dst_range is None:
                dst_range = "any"
            dst = range_to_net(dst_range,
                               re_match.group(9), re_match.group(10),
                               re_match.group(11),
                               usewild=wildcard)
            logging.debug("dst = %r", dst)
        else:
            re_match = re.match(STANDARD_ACL_RE, line, re.X)
            if re_match:
                logging.debug("STANDARD_ACL_RE = %r", line)
                # XXX ugly code
                if re_match.group(4) is None:
                    src = range_to_net(re_match.group(2), None,
                                       re_match.group(3), "0.0.0.0")
                    logging.debug("biz = %r", src)
                else:
                    src = range_to_net(re_match.group(2), None,
                                       re_match.group(3), re_match.group(4))
                    logging.debug("baz = %r", src)
                dst = iptosubnet("0.0.0.0/0")
                logging.debug("qux = %r", dst)
            else:
                re_match = re.match(NETWORK_OBJECT_HOST_RE, line, re.X)
                if re_match:
                    logging.debug("got NETWORK_OBJECT_HOST_RE")
                    src = iptosubnet(re_match.group(1))
                    dst = iptosubnet("0.0.0.0/0")
                    logging.debug("src = %r", src)
                else:
                    re_match = re.match(NETWORK_OBJECT_NETWORK_RE, line, re.X)
                    if re_match:
                        logging.debug("NETWORK_OBJECT_NETWORK_RE, line = %r",
                                      line)
                    else:
                        re_match = re.search(SUBNET_WITH_MASK_RE, line, re.X)
                        if re_match:
                            logging.debug("SUBNET_WITH_MASK_RE, line = %r",
                                          line)
                    if re_match:
                        straddr = re_match.group(1)
                        strmask = re_match.group(2)
                        logging.debug("straddr = %r", straddr)
                        logging.debug("strmask = %r", strmask)
                        addr = iptosubnet(straddr)
                        mask = iptosubnet(strmask)
                        logging.debug("addr = %r", addr)
                        logging.debug("mask = %r", mask)
                        preflen = netmasktoprefix(mask.ip)
                        if maskof(preflen) != mask.ip:
                            logging.debug("does not match: %d and %d",
                                          maskof(preflen), mask.ip)
                            continue
                        logging.debug("preflen = %r", preflen)
                        src = Subnet(ip=addr.ip, prefix=preflen)
                        dst = iptosubnet("0.0.0.0/0")
                        logging.debug("src = %s", src)
                    else:
                        re_match = re.search(SUBNET_RE, line, re.X)
                        if re_match:
                            logging.debug("GOT SUBNET_RE, line = %r", line)
                            src = iptosubnet(re_match.group(0))
                            dst = iptosubnet("0.0.0.0/0")
                            logging.debug("src = %r", src)
                        else:
                            last_acl_name = None
                            current_acl_name = None
                            current_acl_line = None
                            continue

        logging.debug('current_acl_name = %r, '
                      'current_acl_line = %r, '
                      'last_acl_name = %r',
                      current_acl_name, current_acl_line, last_acl_name)
        if (match_subnet_prefixrange(src, srcmatch) and
                match_subnet_prefixrange(dst, dstmatch)):
            if current_acl_name and (last_acl_name is None
                                     or last_acl_name != current_acl_name):
                assert current_acl_line is not None
                print("%5d %s" % (current_acl_line, current_acl_name))
                last_acl_name = current_acl_name
            print("%5d %s" % (line_num, line))

if __name__ == '__main__':
    main()

# vim: filetype=python et ts=4 wm=0:
