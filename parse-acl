#!/usr/bin/env python

"""
Find prefix ranges in ACLs from a Cisco router or firewall

The idea is to find all ACLs which apply to a certain host or
network range.

To do:

* Implement ASA ACLs using the following keywords:
    object network
    object service
    object-group network
    object-group protocol
    object-group service
    access-list
* Match more than the first IP address on a line (only the first IP
  address on a line is tested -- all others are ignored).
* Match ranges (correctly accounting for overlaps, either in whole or part)
"""

import sys
import re
import socket
import struct
import argparse
import logging
from typing import Optional, NamedTuple, Union, Sequence, Any, Match, Tuple

# Set some types used for holding data
#
IP = int
# For use when 3.9 is available
#PrefixLength = Annotated[int, ValueRange(0, 32)]
PrefixLength = int

class Subnet(NamedTuple):
    """Represent an IP address or subnet, with prefix length"""
    ip: IP
    prefix: PrefixLength = 32
    def __repr__(self) -> str:
        return 'Subnet(' + subnettoip(self) + ')'

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: Subnet
    ge: PrefixLength
    le: PrefixLength

# Return type for routines that match subnets.  The usual format is a
# tuple with the source and destination subnets.  If a new header is
# detected, then the tuple is (str, None), where the string is the name
# of the header.  In the case that a line should be ignored without
# resetting the header state variables, it is the tuple (None, None).
#
SrcDst = Tuple[Union[Subnet, str, None], Optional[Subnet]]

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        [ ]netmask
    )?
    [ ]
    (''' + IP_ADDR + r''')
'''

# $1 = IP address, $2 = prefix length or None
SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/ (\d+)
    )?
'''

PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

NETWORK_OBJECT_RE = r'''
    \b
    network-object
    [ ]
'''

NETWORK_OBJECT_HOST_RE = r'''
    ^
    [ ]*
    (?:
    ''' + NETWORK_OBJECT_RE + '''
    )?
    host
    [ ]
    (''' + IP_ADDR + r''')
'''

NETWORK_OBJECT_NETWORK_RE = r'''
    ^
    [ ]*
    ''' + NETWORK_OBJECT_RE + r'''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

# Occurs under object network NAME
RANGE_RE = r'''
    ^
    [ ]*
    range[ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

ROUTE_RE = r'''
    ^
    [ ]*
    route[ ]
    \S+
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    \S+
    $
'''

IP_NAT_POOL_RE = r'''
    [ ]*
    ip[ ]nat[ ]pool[ ]
    \S+[ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    netmask[ ]
    (''' + IP_ADDR + r''')
'''

IP_NAT_INSIDE_SOURCE_STATIC_RE = r'''
    [ ]*
    ip[ ]nat[ ]inside[ ]source[ ]static[ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

# Limit of 8 IP addresses due to the way the matcher works.  Ideally,
# there would be one regex for the continuation IP addresses, but Python
# only returns the last match of a group which matches multiple times.
#
# See the documentation for group():
# https://docs.python.org/3/library/re.html#re.Match.group
#
SMTP_SERVER_RE = r'''
    [ ]*
    smtp-server[ ]
          (''' + IP_ADDR + r''')
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
    (?:[ ](''' + IP_ADDR + r'''))?
'''

### ACL matching

# ip access-list extended network-services-in

ACL_HEADER = r'''
    ^
    (?:
        ip[ ]access-list[ ](?:standard|extended)
        | object(?:-group)?[ ]network
        | interface
    )
    [ ](\S+)
'''

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

# $1 = permit/deny, $2 = any or IP and mask, $3 == IP, $4 = subnet mask or None
STANDARD_ACL_RE = r'''
    (?:
        access-list[ ]\d+
    )?
    [ ]
    (permit|deny)[ ]
    (
        any
        | (''' + IP_ADDR + r''')
          (?:
              [ ] (''' + IP_ADDR + r''')
          )?
    )
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

EXTENDED_ACL_RE = r'''
    (?:
        access-list[ ]\d+
    )?
    [ ]
    (permit|deny)
    [ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    (?:
        [ ] eq [ ] (\S+)
    |
        [ ] range [ ] \S+ [ ] \S+
    )?
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    (?:[ ]eq[ ](\S+))?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

EXTENDED_ASA_ACL_RE = r'''
    access-list[ ]
    \S+[ ]
    extended[ ]
    (permit|deny)[ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)[ ]
    (any4?|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' \
        + IP_ADDR + r'''))
    (?:
        [ ] eq [ ] (\S+)
    |
        [ ] range [ ] \S+ [ ] \S+
    )?
    [ ]
    (any4?|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' \
        + IP_ADDR + r'''))
    (?:[ ]eq[ ](\S+))?
'''

EXTENDED_IGNORE_RE = r'''
    (?:
        (?: access-list[ ]\d+ )? [ ] (?:dynamic|evaluate|remark)[ ]
        | [ ]description[ ]
        | [ ]port-object[ ]
        | [ ]group-object[ ]
        | [ ]vlan[ ]
        | [ ]nameif[ ]
        | [ ]security-level[ ]
    )
'''

### IP address utility functions

def iptoint(ip: str) -> IP:
    """Convert an IP address as a string into the internal IP format"""
    result: IP = struct.unpack("!I", socket.inet_aton(ip))[0]
    return result

def inttoip(int_: IP) -> str:
    """Convert the internal IP format into an IP address as a string"""
    return socket.inet_ntoa(struct.pack("!I", int_))

def iptosubnet(ip: str) -> Subnet:
    """Convert a string with an IP address and prefix into the internal
    Subnet format"""

    parts = ip.split('/')
    if len(parts) == 1:
        return Subnet(ip=iptoint(parts[0]))
    elif len(parts) == 2:
        return Subnet(ip=iptoint(parts[0]), prefix=int(parts[1]))
    else:
        raise SyntaxError('subnet must have zero or one slashes')

def subnettoip(subnet: Subnet) -> str:
    """Convert the internal Subnet format into a string with an IP address
    and prefix"""
    return inttoip(subnet.ip) + '/' + str(subnet.prefix)

def maskof(length: PrefixLength) -> IP:
    """Given a prefix length, return the internal representation IP subnet
    mask.  This mask can be used in bitwise operations with an IP address."""
    return (-1 << (32 - length)) & 0xffffffff

def wildtonetmask(wild: str) -> IP:
    """Convert a wildcard mask as a string into the internal IP format
    of a net mask"""
    wildmask = iptoint(wild)
    netmask = (~wildmask) & 0xffffffff
    return netmask

def netmasktoprefix(mask: IP) -> PrefixLength:
    """Given an internal representation of a subnet mask, return the
    corresponding prefix length."""
    prefix = 32

    # Change netmask to a wildcard so that all of the 1s are on the right.
    # Can't use wildtonetmask here since mask is not a string.
    mask = (~mask) & 0xffffffff
    while mask > 0:
        mask >>= 1
        prefix -= 1
    return prefix

### IP subnet matching

def match_subnet(subnet1: Subnet, subnet2: Subnet,
                 minlen: PrefixLength, maxlen: PrefixLength) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    def subnet_test(addr1: IP, addr2: IP, prefixlen: PrefixLength) -> bool:
        """Test two IPv4 addresses, ADDR1 and ADDR2, for equality when
        normalized to a common prefix length PREFIXLEN."""
        mask = maskof(prefixlen)
        return (addr1 & mask) == (addr2 & mask)

    len1 = subnet1.prefix
    len2 = subnet2.prefix
    containmentp = subnet_test(subnet1.ip, subnet2.ip, min(len1, len2))
    return containmentp and minlen <= len1 <= maxlen

def containment(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Return True if subnet1 is a subnet of subnet2 or vice versa"""
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefix)

def is_contained_in(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, 32)

def matches_exact(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if subnet1 and subnet2 are identical, with the same IP
    and prefix length"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, subnet2.prefix)

def match_subnet_prefixrange(subnet: Subnet, prefix: PrefixRange) -> bool:
    """Test if subnet falls within the subset or superset given
    by the prefix range prefix"""
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Parsing

# XXX redefine to make more sense (e.g., "host" only is used in extended
# acls but not in standard acls)
def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: str, usewild: bool = True) -> Subnet:
    """Given the parts of a regex matching an ACL in the text,
    convert it to a subnet.  If usewild is set, reverse the bits of
    the re_mask variable.  The regexes that are used in the matching
    are EXTENDED_ACL_RE, EXTENDED_ASA_ACL_RE, and STANDARD_ACL_RE."""
    if re_range.startswith('host '):
        assert re_host is not None
        net = iptoint(re_host)
        mask = 32
    elif re_range in ("any", "any4"):
        net, mask = iptosubnet("0.0.0.0/0")
    else:
        net = iptoint(re_net)
        if usewild:
            mask = netmasktoprefix(wildtonetmask(re_mask))
        else:
            mask = netmasktoprefix(iptoint(re_mask))
    return Subnet(ip=net, prefix=mask)

# LEN: undefined GE: undefined LE: undefined   ge=32,  le=32
# LEN: undefined GE: undefined LE: defined     ge=32,  le=LE
# LEN: undefined GE: defined   LE: defined     ge=GE,  le=LE
# LEN: undefined GE: defined   LE: undefined   ge=GE,  le=32

# LEN: defined   GE: defined   LE: undefined   ge=GE,  le=32
# LEN: defined   GE: defined   LE: defined     ge=GE,  le=LE
# LEN: defined   GE: undefined LE: defined     ge=LEN, le=LE
# LEN: defined   GE: undefined LE: undefined   ge=LEN, le=LEN
def normalize_prefix_lengths(ip: int,
                             length: Optional[int],
                             ge: Optional[int],
                             le: Optional[int]) -> PrefixRange:
    """Fill in the parts of a prefix range using default or derived
    values if those parts are None"""
    if length is None:
        length = 32
    if le is None:
        if ge is None:
            ge = le = length
        else:
            le = 32
    elif ge is None:
        ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(Subnet(ip=ip, prefix=length), ge, le)

def safe_int(intstr: Optional[str]) -> Optional[int]:
    """Convert a string to an integer, or None is intstr is None"""
    if intstr is None:
        return None
    return int(intstr)

def parse_prefix_list(arg: str) -> PrefixRange:
    """Given the string representation of a prefix range, convert it
    to a PrefixRange object"""
    re_match = re.match(PREFIX_RE, arg, re.X)
    if not re_match:
        raise SyntaxError('invalid prefix range')
    ip = iptoint(re_match.group(1))
    length = safe_int(re_match.group(2))
    ge = safe_int(re_match.group(3))
    le = safe_int(re_match.group(4))
    return normalize_prefix_lengths(ip, length, ge, le)

def normalized(subnet: Subnet) -> bool:
    """Return True if host portion of the IP address is all zeroes."""
    ip = subnet.ip
    length = subnet.prefix
    return ip & maskof(length) == ip

def addrmasktosubnet(straddr: str, strmask: str) -> Subnet:
    """Convert an IP address and a separate IP address used as
    a network mask into a subnet object.  For instance, convert
    "192.168.100.0", "255.255.255.0" into 192.168.100.0/24."""

    logging.debug("straddr = %r", straddr)
    logging.debug("strmask = %r", strmask)
    addr = iptosubnet(straddr)
    mask = iptosubnet(strmask)
    logging.debug("addr = %r", addr)
    logging.debug("mask = %r", mask)
    preflen = netmasktoprefix(mask.ip)
    assert maskof(preflen) == mask.ip
    logging.debug("preflen = %r", preflen)
    subnet = Subnet(ip=addr.ip, prefix=preflen)
    logging.debug("subnet = %r", subnet)
    return subnet

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    """Conduct various tests on the arguments, used for testing the script"""
    ipaddr1 = iptosubnet(ipaddr1_str)
    ipaddr2 = iptosubnet(ipaddr2_str)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

class PrefixRangeAction(argparse.Action):
    """Customized action for the PrefixLength arguments"""
    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: Union[str, Sequence[Any], None],
                 option_string: Optional[str] = None) -> None:
        """Set the PrefixLength argument"""
        assert isinstance(values, str)
        direction = 'source' if option_string == '-s' else 'destination'
        srcmatch = parse_prefix_list(values)
        if not normalized(srcmatch.subnet):
            print("warning: %s subnet not normalized (%s)"
                  % (direction, subnettoip(srcmatch.subnet)))
        setattr(namespace, self.dest, srcmatch)

def getoptions() -> argparse.Namespace:
    """Parse the command-line options"""

    parser = argparse.ArgumentParser(
        description='Find prefix ranges in ACLs from a Cisco '
                    'router or firewall')

    parser.add_argument('-s', '--source',
                        help='source prefix range to match in configuration',
                        # Match anything by default
                        default=PrefixRange(iptosubnet("0.0.0.0/0"),
                                            ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='SOURCE')
    parser.add_argument('-d', '--destination',
                        help='destination prefix range to match in '
                             'configuration',
                        # Match anything by default
                        default=PrefixRange(iptosubnet("0.0.0.0/0"),
                                            ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='DESTINATION')
    parser.add_argument('-x', '--reverse',
                        help='swap the source and destinaton addresses '
                             '(for convenience)',
                        action='store_true')
    parser.add_argument('-v', '--verbose',
                        help='be verbose',
                        action='store_const',
                        default=logging.INFO,
                        const=logging.DEBUG,
                        dest='log_level')
    parser.add_argument('-t', '--test',
                        nargs=4,
                        help='test the arguments from the command line '
                             '(source1, source2, minlen, maxlen)',
                        action='extend')

    return parser.parse_args()

# Parse routines

def acl_header(re_match: Match[str]) -> SrcDst:
    """Match the header of a standard or extended ACL"""
    logging.debug("got ACL_HEADER = %r", re_match.groups())
    # Possible to use group(1) here if just the ACL name is wanted
    return re_match.group(0), None

def extended_ignore_re(re_match: Match[str]) -> SrcDst:
    """Match a line that is part of an object, but should be ignored.
    The main purpose of this is to make sure that current_acl_name
    stays set to the same value while parsing the object.  Once a
    line matches that is not in the object, current_acl_name can set
    to another value or None."""
    assert re_match.groups() == ()
    logging.debug("got EXTENDED_IGNORE_RE = %r", re_match.groups())
    # Do not reset current_acl_name (parser is in middle of object)
    return None, None

def range_re(re_match: Match[str]) -> SrcDst:
    """Match a range statement"""
    logging.debug("got RANGE_RE = %r", re_match.groups())
    start = re_match.group(1)
    end = re_match.group(2)             # Ignored for now
    logging.debug("range %r %r", start, end)
    return iptosubnet(start), iptosubnet('0.0.0.0/0')

def route_re(re_match: Match[str]) -> SrcDst:
    """Match a route statement"""
    logging.debug("got ROUTE_RE = %r", re_match.groups())
    src = re_match.group(1)
    msk = re_match.group(2)
    dst = re_match.group(3)             # Ignored for now
    logging.debug("route %r %r %r", src, msk, dst)
    return addrmasktosubnet(src, msk), iptosubnet('0.0.0.0/0')

def handle_extended_acl(re_match: Match[str], wildcard: bool) -> SrcDst:
    """Extract values from the various formats for an extended ACL.
    The wildcard variable can be set to True if the subnet mask is
    inversed (such as Cisco routers)."""

    # XXX needs to work when both -s and -d specified (logical or)
    # XXX needs error checking
    # XXX $7 and $12 are source or destination ports (if any)
    logging.debug("wildcard = %r", wildcard)
    src = range_to_net(re_match.group(3), re_match.group(4),
                       re_match.group(5), re_match.group(6),
                       usewild=wildcard)
    logging.debug("src = %r", src)
    dst_range = re_match.group(8)
    if dst_range is None:
        dst_range = "any"
    dst = range_to_net(dst_range,
                       re_match.group(9), re_match.group(10),
                       re_match.group(11),
                       usewild=wildcard)
    logging.debug("dst = %r", dst)
    return src, dst

def extended_acl_re(re_match: Match[str]) -> SrcDst:
    """Match the EXTENDED_ACL_RE regex"""
    logging.debug("got EXTENDED_ACL_RE = %r", re_match.groups())
    return handle_extended_acl(re_match, wildcard=True)

def extended_asa_acl_re(re_match: Match[str]) -> SrcDst:
    """Match the EXTENDED_ASA_ACL_RE regex"""
    logging.debug("got EXTENDED_ASA_ACL_RE = %r", re_match.groups())
    return handle_extended_acl(re_match, wildcard=False)

def standard_acl_re(re_match: Match[str]) -> SrcDst:
    """Match the STANDARD_ACL_RE regex"""
    logging.debug("got STANDARD_ACL_RE = %r", re_match.groups())
    # XXX ugly code
    if re_match.group(4) is None:
        src = range_to_net(re_match.group(2), None,
                           re_match.group(3), "0.0.0.0")
        logging.debug("biz = %r", src)
    else:
        src = range_to_net(re_match.group(2), None,
                           re_match.group(3), re_match.group(4))
        logging.debug("baz = %r", src)
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

def network_object_host_re(re_match: Match[str]) -> SrcDst:
    """Match the NETWORK_OBJECT_HOST_RE regex"""
    logging.debug("got NETWORK_OBJECT_HOST_RE = %r", re_match.groups())
    src = iptosubnet(re_match.group(1))
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

def handle_subnet(straddr: str, strmask: str) -> SrcDst:
    """Handle configuration lines that have an IP address and a
    separate network mask (not a prefix)."""
    src = addrmasktosubnet(straddr, strmask)
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

def network_object_network_re(re_match: Match[str]) -> SrcDst:
    """Match the NETWORK_OBJECT_NETWORK_RE regex"""
    logging.debug("got NETWORK_OBJECT_NETWORK_RE = %r", re_match.groups())
    return handle_subnet(re_match.group(1), re_match.group(2))

def ip_nat_pool_re(re_match: Match[str]) -> SrcDst:
    """Match the IP_NAT_POOL_RE regex"""
    logging.debug("got IP_NAT_POOL_RE = %r", re_match.groups())
    # Ignore re_match.group(2) for now
    return handle_subnet(re_match.group(1), re_match.group(3))

def ip_nat_inside_source_static_re(re_match: Match[str]) -> SrcDst:
    """Match the IP_NAT_INSIDE_SOURCE_STATIC_RE regex"""
    logging.debug("got IP_NAT_INSIDE_SOURCE_STATIC_RE = %r", re_match.groups())
    # Ignore re_match.group(2) for now
    src = iptosubnet(re_match.group(1))
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

def smtp_server_re(re_match: Match[str]) -> SrcDst:
    """Match the SMTP_SERVER_RE regex"""
    logging.debug("got SMTP_SERVER_RE = %r", re_match.groups())
    # Ignore multiple matches for now
    src = iptosubnet(re_match.group(1))
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

def subnet_with_mask_re(re_match: Match[str]) -> SrcDst:
    """Match the SUBNET_WITH_MASK_RE regex"""
    logging.debug("got SUBNET_WITH_MASK_RE = %r", re_match.groups())
    return handle_subnet(re_match.group(1), re_match.group(2))

def subnet_re(re_match: Match[str]) -> SrcDst:
    """Match the SUBNET_RE regex"""
    logging.debug("got SUBNET_RE = %r", re_match.groups())
    src = iptosubnet(re_match.group(0))
    dst = iptosubnet("0.0.0.0/0")
    return src, dst

MATCH_RE_TABLE_RAW = (
    (ACL_HEADER, acl_header),
    (EXTENDED_IGNORE_RE, extended_ignore_re),
    (RANGE_RE, range_re),
    (ROUTE_RE, route_re),
    (EXTENDED_ACL_RE, extended_acl_re),
    (EXTENDED_ASA_ACL_RE, extended_asa_acl_re),
    (STANDARD_ACL_RE, standard_acl_re),
    (NETWORK_OBJECT_HOST_RE, network_object_host_re),
    (NETWORK_OBJECT_NETWORK_RE, network_object_network_re),
    (IP_NAT_POOL_RE, ip_nat_pool_re),
    (IP_NAT_INSIDE_SOURCE_STATIC_RE, ip_nat_inside_source_static_re),
    (SMTP_SERVER_RE, smtp_server_re),
    (SUBNET_WITH_MASK_RE, subnet_with_mask_re),
    (SUBNET_RE, subnet_re),
)

MATCH_RE_TABLE = tuple((re.compile(re_pattern, re.X), re_func)
                       for re_pattern, re_func in MATCH_RE_TABLE_RAW)

def find_match(line: str) -> Optional[SrcDst]:
    """Iterate through all of the different regexes that can match
    a line in the configuration that has an IP address or a subnet.
    If a match is found, return the source and destination subnets
    found.  If only a source subnet was found, the destination will
    be 0.0.0.0/0.  As a special case, if source address is a string
    instead, it means a header with an object name was matched.
    Another special case is when both the source and destination
    subnets are set to None, which means to ignore the line."""

    for match_re, match_func in MATCH_RE_TABLE:
        re_match = match_re.match(line)
        if not re_match:
            continue
        src, dst = match_func(re_match)
        logging.debug("src = %r, dst = %r", src, dst)
        return src, dst
    return None

def parse_config(srcmatch: PrefixRange, dstmatch: PrefixRange) -> None:
    """Parse the configuration and search for lines which match ACLs,
    network objects, or other places IP addresses are used."""

    last_acl_name = None
    current_acl_name = None
    current_acl_line = None
    for line_num, line in enumerate(sys.stdin, start=1):
        line = line.rstrip('\r\n')
        logging.debug("linenum = %r, line = %r", line_num, line)
        retval = find_match(line)
        if retval is None:
            logging.debug("find_match() found no match at all")
            current_acl_name = None
            continue
        src, dst = retval
        if src is None:
            # Ignored line
            continue
        if isinstance(src, str):
            # New header for network object
            current_acl_name = src
            current_acl_line = line_num
            continue
        assert isinstance(src, Subnet)
        assert isinstance(dst, Subnet)

        logging.debug('current_acl_name = %r, '
                      'current_acl_line = %r, '
                      'last_acl_name = %r',
                      current_acl_name, current_acl_line, last_acl_name)
        # See if the src/dst from the config matches srcmatch/dstmatch
        if (match_subnet_prefixrange(src, srcmatch) and
                match_subnet_prefixrange(dst, dstmatch)):
            if current_acl_name and (last_acl_name is None
                                     or last_acl_name != current_acl_name):
                # Header for the ACL changed, so print it now
                assert current_acl_line is not None
                print("%5d %s" % (current_acl_line, current_acl_name))
                last_acl_name = current_acl_name
            print("%5d %s" % (line_num, line))

### Main program

def main() -> None:
    """Main routine"""

    args = getoptions()
    assert isinstance(args.source, PrefixRange)
    assert isinstance(args.destination, PrefixRange)
    assert isinstance(args.log_level, int)
    assert isinstance(args.reverse, bool)

    srcmatch = args.source
    dstmatch = args.destination

    # Set up logging
    logging.basicConfig(level=args.log_level,
                        format="%(levelname)s:%(funcName)s:"
                               "%(lineno)d:%(message)s")

    if args.test:
        assert isinstance(args.test, list)
        testsubnets(ipaddr1_str=args.test[0], ipaddr2_str=args.test[1],
                    minlen_str=args.test[2], maxlen_str=args.test[3])
        sys.exit(0)

    if args.reverse:
        srcmatch, dstmatch = dstmatch, srcmatch

    logging.debug("srcmatch = %r", srcmatch)
    logging.debug("dstmatch = %r", dstmatch)

    parse_config(srcmatch, dstmatch)

if __name__ == '__main__':
    main()

# vim: filetype=python et ts=4 wm=0:
