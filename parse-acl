#!/usr/bin/env python

"""
Find prefix ranges in ACLs from a Cisco router or firewall

The idea is to find all ACLs which apply to a certain host or
network range.

To do:

* Match NAT statements
* Match ranges (correctly accounting for overlaps, either in whole or part)
* Test cases

Copyright Â© 2022 J. Cowley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License,
or any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import re
from ipaddress import IPv4Network, IPv4Address, NetmaskValueError
from socket import gethostbyname_ex, gaierror
import argparse
import logging
from itertools import product
from typing import (Optional, NamedTuple, Union, Sequence, Any, Match,
                    Iterable, Tuple, Dict, Set, Pattern, Literal, Collection,
                    TextIO)

# Set some types used for holding data
#
# For use when 3.9 is available
#PrefixLength = Annotated[int, ValueRange(0, 32)]
PrefixLength = int

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: IPv4Network
    ge: PrefixLength
    le: PrefixLength

class Range(NamedTuple):
    """Represent a range of IP addresses"""
    start: IPv4Address
    end: IPv4Address
    def __str__(self) -> str:
        return str(self.start) + ' - ' + str(self.end)

AddrBlock = Union[IPv4Network, Range]

class SrcDst(NamedTuple):
    """A match object with source and destination networks"""
    src: AddrBlock
    dst: AddrBlock

# Return type for routines that match subnets.  It is a two-element
# tuple, where the first element is a string identifier that specifies
# the type of the second element.  The usual format is type 'srcdst'
# and a tuple with the source and destination subnets.  If a new header
# is detected, the type is 'header' and a tuple of type (str, str),
# where the first string is the entire line, and the second string
# is the name of the object.
#
Matchtype = Literal['srcdst', 'position', 'header', 'remark', 'aclname']
Object = Union[SrcDst,                             # srcdst
               int,                                # position
               Tuple[str, str],                    # header
               str]                                # remark, aclname

class MatchObj(NamedTuple):
    """Generic return type from the matching functions"""
    matchtype: Matchtype
    obj: Object

### Network objects

# Dictionary of subnets based on the name of the ACL header, the
# network object, or any other identifier from the configuration.
# Each entry contains a list of subnets (or IP addresses) for that
# object, even if some of the entries were derived recursively from
# other objects.
OBJECT_DICT: Dict[str, Set[AddrBlock]] = {}

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

# $1 = IP subnet
# $2 = IP net mask
SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        [ ](?:net)?mask
    )?
    [ ](''' + IP_ADDR + r''')
'''

# $1 = IP subnet
# $2 = prefix length or None
SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/ (\d+)
    )?
'''

# $1 = IP subnet
# $2 = prefix length or None
# $3 = ge value or None
# $4 = le value or None
PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

# $1 = object name
NET_OR_GRP_OBJECT_RE = r'''
    ^
    [ ]*
    (?:
        group-object
        |network-object[ ]object
    )[ ]
    (\S+)
'''

# $1 = starting IP address
# $2 = ending IP address
# $3 = net mask
IP_NAT_POOL_RE = r'''
    ^
    [ ]*
    ip[ ]nat[ ]pool[ ]
    \S+[ ]
    (''' + IP_ADDR + r''')[ ]
    (''' + IP_ADDR + r''')[ ]
    netmask[ ]
    (''' + IP_ADDR + r''')
'''

### ACL matching

# ip access-list extended network-services-in

# $1 = object name
HEADER_RE = r'''
    ^
    (?:
        ip[ ]access-list[ ](?:standard|extended)
        |object(?:-group)?[ ]network
        |interface
    )[ ]
    (\S+)
'''

EXTENDED_ASA_ACL_REMARK_RE = r'''
    ^
    [ ]*
    access-list[ ]
    (\S+)[ ]
    remark[ ]
    .*
'''

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

## ASA standard named

# access-list example standard permit host 10.11.12.13

# $1 = ACL name
# $2 = any, host, or IP and mask
# $3 = source host IP address or None
# $4 = IP or None
# $5 = subnet mask or None
STANDARD_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ](?:\d+|(\S+)[ ]standard)
    )?
    [ ]
    (?:permit|deny)[ ]+
    (
        any
        | host[ ](''' + IP_ADDR + r''')
        | (''' + IP_ADDR + r''')
          (?:
              [ ](''' + IP_ADDR + r''')
          )?
    )
    [ ]*
    $
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

# The extra ()s are to make the indexes of the back references the same
# as the EXTENDED_ASA_ACL_RE regex.  This is because both regexes share
# handle_extended_acl(), which uses the same indexes for both regexes.
EXTENDED_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ]\d+
    )?
    ()
    [ ]
    (?:permit|deny)[ ]+
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:
        [ ]eq[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
    )?
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:[ ]eq[ ]\S+)?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

# $1 = ACL name
# $2 = protocol
# $3 = protocol object name or None
# $4 = source IP address (all)
# $5 = source host IP address
# $6 = source subnet IP address
# $7 = source netmask
# $8 = source object group name
# $9 = source port object group name
# $10 = destination IP address (all)
# $11 = destination host IP address
# $12 = destination subnet IP address
# $13 = destination netmask
# $14 = destination object group name
# $15 = destination port object group name
EXTENDED_ASA_ACL_RE = r'''
    ^
    [ ]*
    access-list[ ]
    (\S+)[ ]
    (?:extended[ ])?
    (?:permit|deny)[ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf
     |pcp|pim|object(?:-group)?[ ](\S+))[ ]
    (
        any4?
        |host[ ](''' + IP_ADDR + r''')
        |(''' + IP_ADDR + r')[ ](' + IP_ADDR + r''')
        |object(?:-group)?[ ](\S+)
    )
    (?:
        [ ](?:eq|gt)[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
        |[ ]object(?:-group)?[ ](\S+)
    )?
    [ ]
    (
        any4?
        |host[ ](''' + IP_ADDR + r''')
        |(''' + IP_ADDR + r')[ ](' + IP_ADDR + r''')
        |object(?:-group)?[ ](\S+)
    )
    (?:
        [ ](?:alternate-address|conversion-error|echo(?:-reply)?
              |information-(?:reply|request)|mask-(?:reply|request)
              |mobile-redirect|parameter-problem|redirect
              |router-(?:advertisement|solicitation)|source-quench
              |time-exceeded|timestamp-(?:reply|request)|traceroute
              |unreachable
           )
        |[ ](?:eq|neq|gt|lt)[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
        |[ ]object(?:-group)?[ ](\S+)
    )?
    (?:[ ]log
       (?:[ ](?:debugging|informational|notifications|warnings|errors|critical
                |alerts|emergencies|[0-7]))?
    )?
    (?:[ ]interval[ ]\d+)?
    (?:[ ]time-range[ ]\S+)?
    [ ]*
    $
'''

OBJECT = r'''(\S+)'''
INTF = r'''[a-zA-Z0-9_-]+'''
TWICE_NAT_RE = r'''
    ^nat[ ]
    \(''' + INTF + r',' + INTF + r'''\)[ ]
    (?:after-auto[ ])?
    source[ ]
    (?:static|dynamic)[ ]
    (?:any|''' + OBJECT + r''')
    (?:[ ](?:any|interface|''' + OBJECT + r'''))?
    (?:[ ]pat-pool[ ](?:\S+|interface)
        (?:[ ]extended)?
        (?:[ ]flat)?
        (?:[ ]include-reserve)?
        (?:[ ]round-robin)?
        (?:[ ]dns)?
    )?
    (?:
        [ ]+destination[ ]static[ ]
        (?:interface|''' + OBJECT + r''')[ ]
        (?:any|''' + OBJECT + r''')
    )?
    (?:[ ]service[ ]''' + OBJECT + r'''[ ]''' + OBJECT + r''')?
    (?:[ ]net-to-net)?
    (?:[ ]dns)?
    (?:[ ]unidirectional)?
    (?:[ ]no-proxy-arp)?
    (?:[ ]route-lookup)?
    (?:[ ]inactive)?
    (?:[ ]description[ ].*)?
    $
'''

HOSTNAME = r'(?:[a-zA-Z0-9_-]+\.)*[a-zA-Z0-9_-]+\.?'
FQDN_RE = r'''
    [ ]+
    fqdn[ ](?:v4[ ])?(''' + HOSTNAME + r''')
'''

RANGE_RE = r'''
    ^
    [ ]+
    range[ ](''' + IP_ADDR + r''')[ ](''' + IP_ADDR + r''')
'''

### IP address utility functions

ANY = IPv4Network("0.0.0.0/0")

def match_subnet(subnet1: IPv4Network, subnet2: IPv4Network,
                 minlen: PrefixLength, maxlen: PrefixLength) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    return subnet1.overlaps(subnet2) and minlen <= subnet1.prefixlen <= maxlen

def containment(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Return True if subnet1 is a subnet of subnet2 or vice versa"""
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefixlen)

def is_contained_in(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefixlen, 32)

def matches_exact(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if subnet1 and subnet2 are identical, with the same IP
    and prefix length"""
    return match_subnet(subnet1, subnet2, subnet2.prefixlen, subnet2.prefixlen)

def match_range(candidate_range: Range, prefix: PrefixRange) -> bool:
    """Match a range of addresses against the search prefix.  This is
    equivalent to searching a bunch of host addresses individually.
    Therefore, the match is only considered if the prefix allows
    host addresses.  If so, look for any overlap of the prefix with
    the range."""

    # Only match if the match includes host addresses
    if prefix.le != 32:
        return False
    candidate_start, candidate_end = candidate_range
    logging.debug("candidate start = %r, end = %r",
                  candidate_start, candidate_end)
    logging.debug("prefix = %r", prefix)
    prefix_subnet = prefix.subnet
    match_start = IPv4Address(prefix_subnet.network_address)
    match_end = IPv4Address(prefix_subnet.broadcast_address)
    logging.debug("match_start = %r, match_end = %r", match_start, match_end)
    assert candidate_start <= candidate_end
    # Rule out non-overlaps with the range
    if candidate_start < match_start and candidate_end < match_start:
        return False
    if candidate_start > match_end:
        return False
    # What is left is an overlap
    return True

def match_subnet_prefixrange(subnet: AddrBlock, prefix: PrefixRange) -> bool:
    """Test if subnet falls within the subset or superset given
    by the prefix range prefix"""
    if isinstance(subnet, Range):
        return match_range(subnet, prefix)
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Parsing

def safe_IPv4Network(ipstr: str) -> IPv4Network:
    """Convert a string to an IPv4Network but issue a warning if the network
    is not normalized (host bits are not zero)"""
    try:
        net = IPv4Network(ipstr, strict=True)
    except ValueError:
        # An exception is raised if the network is not normalized
        net = IPv4Network(ipstr, strict=False)
        print("warning: %s normalized to %s" % (ipstr, net))
    return net

def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: Optional[str]) -> IPv4Network:
    """Given the parts of a regex matching an ACL in the text,
    convert it to a subnet.  The regexes that are used in the matching
    are EXTENDED_ACL_RE, EXTENDED_ASA_ACL_RE, and STANDARD_ACL_RE."""
    if re_range.startswith('host '):
        assert re_host is not None
        net = re_host
    elif re_range in ("any", "any4"):
        net = '0.0.0.0/0'
    elif re_mask is None:
        net = re_net
    else:
        net = re_net + '/' + re_mask
    return safe_IPv4Network(net)

def normalize_prefix_lengths(ip: IPv4Network,
                             ge: Optional[PrefixLength],
                             le: Optional[PrefixLength]) -> PrefixRange:
    """Fill in the parts of a prefix range using default or derived
    values if those parts are None.  Any time the prefix length is not
    given, it defaults to 32.  If ge or le is not given, it defaults
    to the prefix length (except for special cases to match Cisco's
    prefix-list behavior)."""

    length = ip.prefixlen
    if le is None:
        if ge is None:
            ge = le = length
        elif ge > length:
            # Ordinarily generates an error, but allow this special
            # case to match Cisco's behavior (e.g., '10.0.0.0/8 ge 9')
            le = 32
        else:
            le = length
    elif ge is None:
        if le < length:
            # Same special case, but in reverse (e.g., '10.0.0.0/8 le 7')
            ge = 0
        else:
            ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(ip, ge, le)

def safe_int(intstr: Optional[str]) -> Optional[int]:
    """Convert a string to an integer, or None is intstr is None"""
    if intstr is None:
        return None
    return int(intstr)

def parse_prefix_list(arg: str) -> PrefixRange:
    """Given the string representation of a prefix range, convert it
    to a PrefixRange object"""
    re_match = re.match(PREFIX_RE, arg, re.X)
    if not re_match:
        raise SyntaxError('invalid prefix range')
    ip = re_match.group(1)
    length = re_match.group(2)
    if length is not None:
        ip += '/' + length
    net = safe_IPv4Network(ip)
    ge = safe_int(re_match.group(3))
    le = safe_int(re_match.group(4))
    return normalize_prefix_lengths(net, ge, le)

def addrmasktosubnet(straddr: str, strmask: str) -> Optional[IPv4Network]:
    """Convert an IP address and a separate IP address used as
    a network mask into a subnet object.  For instance, convert
    "192.168.100.0", "255.255.255.0" into 192.168.100.0/24."""

    logging.debug("straddr = %r", straddr)
    logging.debug("strmask = %r", strmask)
    net = straddr + '/' + strmask
    logging.debug("net = %r", net)
    try:
        subnet = IPv4Network(net, strict=False)
    except NetmaskValueError:
        logging.debug('invalid mask for addr, returning None')
        return None
    logging.debug("subnet = %r", subnet)
    return subnet

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    """Conduct various tests on the arguments, used for testing the script"""
    ipaddr1 = IPv4Network(ipaddr1_str, strict=False)
    ipaddr2 = IPv4Network(ipaddr2_str, strict=False)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

class PrefixRangeAction(argparse.Action):
    """Customized action for the PrefixLength arguments"""
    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: Union[str, Sequence[Any], None],
                 option_string: Optional[str] = None) -> None:
        """Set the PrefixLength argument"""
        assert isinstance(values, str)
        srcmatch = parse_prefix_list(values)
        setattr(namespace, self.dest, srcmatch)

def getoptions() -> argparse.Namespace:
    """Parse the command-line options"""

    parser = argparse.ArgumentParser(
        description='Find prefix ranges in ACLs from a Cisco '
                    'router or firewall',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog='''\
A prefix range consists of an IP address (with an optional prefix
length indicating a subnet), and two optional keywords that specify
the minimum and maximum prefix lengths for matches.

    IP[/LENGTH] [ge M] [le N]

The prefix length must be 0 <= length <= 32, and the ge and le
arguments must be 0 <= ge <= le <= 32.

Examples:

1.1.1.1                 Look for a single IP address
1.1.1.0/24              Look for a specific subnet
1.1.1.0/24 le 32        Look for any IP address or subnet in a subnet
1.1.1.0/24 ge 32 le 32  Look for host IP addresses in a subnet
1.1.0.0/16 ge 1 le 32   Look for any IP address or subnet in a subnet
                        and also any supernets except the default route
1.1.1.0/16 ge 0         Look for any supernets of a subnet including
                        the default route
''')

    parser.add_argument('-s', '--source',
                        help='source prefix range to match in configuration',
                        # Match anything by default
                        default=PrefixRange(ANY, ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='SOURCE')
    parser.add_argument('-d', '--destination',
                        help='destination prefix range to match in '
                             'configuration',
                        # Match anything by default
                        default=PrefixRange(ANY, ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='DESTINATION')
    parser.add_argument('-x', '--swap',
                        help='swap the source and destinaton addresses\n'
                             '(for convenience)',
                        action='store_true')
    parser.add_argument('-p', '--duplicate',
                        help='duplicate the source address as the\n'
                             'destination address',
                        action='store_true')
    parser.add_argument('-r', '--or',
                        help='use a logical-or operation instead of\n'
                             'logical-and between source and destination',
                        action='store_true',
                        dest='logicalor')
    parser.add_argument('-v', '--verbose',
                        help='be verbose',
                        action='store_const',
                        default=logging.INFO,
                        const=logging.DEBUG,
                        dest='log_level')
    parser.add_argument('-t', '--test',
                        nargs=4,
                        help='test the arguments from the command line\n'
                             '(source1, source2, minlen, maxlen)',
                        action='extend')
    object_group = parser.add_mutually_exclusive_group()
    object_group.add_argument('-o', '--show-object',
                              help='show the IP addresses for the object',
                              dest='object')
    object_group.add_argument('-O', '--show-objects',
                              help='show the IP addresses for all objects',
                              action='store_true',
                              dest='objects')
    parser.add_argument('-l', '--resolve',
                        help='process fqdn statements by resolving DNS',
                        action='store_true',
                        dest='resolver')
    parser.add_argument('-n', '--line-number',
                        help=('prefix each line of output with the\n'
                              '1-based line number within its input file'),
                        action='store_true',
                        dest='linenumber')
    parser.add_argument('-a', '--acl-lines',
                        help='prefix ACLs with the 1-based line number',
                        action='store_true',
                        dest='acllines')
    parser.add_argument('configs',
                        nargs='*',
                        help='configuration file(s) to read')

    args = parser.parse_args()

    if not args.linenumber and args.acllines:
        parser.error('cannot have -a without -n')

    return args

# Parse routines

def header_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the header of a standard or extended ACL or object"""
    logging.debug("got HEADER_RE = %r", re_match.group(lastidx))
    # Possible to use group(lastidx + 1) here if just the ACL name is wanted
    yield MatchObj('header', (re_match.group(lastidx + 0),
                              re_match.group(lastidx + 1)))

def extended_asa_acl_remark_re(re_match: Match[str],
                               lastidx: int) -> Iterable[MatchObj]:
    """Match the remark statement of a standard or extended ACL"""
    logging.debug("got EXTENDED_ASA_ACL_REMARK_RE = %r",
                  re_match.group(lastidx))
    logging.debug('aclname = %r', re_match.group(lastidx + 1))
    yield MatchObj('aclname', re_match.group(lastidx + 1))
    remark = re_match.group(lastidx)
    yield MatchObj('remark', remark)

def yield_object_subnets(obj_key: str) -> Iterable[AddrBlock]:
    """Yield the subnets from the network object obj_key"""
    logging.debug('obj_key = %r', obj_key)
    if obj_key not in OBJECT_DICT:
        raise SyntaxError('Network object %s not found '
                          '-- possibly corrupt configuration?'
                          % obj_key)
    for value in OBJECT_DICT[obj_key]:
        logging.debug('obj_key value = %r', value)
        yield value

def yield_single_subnet(subnet: IPv4Network) -> Iterable[AddrBlock]:
    """Accept a single argument subnet that will be yielded as needed"""
    yield subnet

def handle_extended_acl(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Extract values from the various formats for an extended ACL."""

    aclname = re_match.group(lastidx + 1)
    if aclname:
        logging.debug('aclname = %r', aclname)
        yield MatchObj('aclname', aclname)

    if re_match.group(lastidx + 4).startswith('object'):
        logging.debug('source address is object %r',
                      re_match.group(lastidx + 8))
        srciter = yield_object_subnets(re_match.group(lastidx + 8))
    else:
        src = range_to_net(re_range=re_match.group(lastidx + 4),
                           re_host=re_match.group(lastidx + 5),
                           re_net=re_match.group(lastidx + 6),
                           re_mask=re_match.group(lastidx + 7))
        logging.debug("src = %r", src)
        srciter = yield_single_subnet(src)

    if re_match.group(lastidx + 10).startswith('object'):
        dstgroup = re_match.group(lastidx + 14)
        logging.debug('dstgroup = %r', dstgroup)
        if dstgroup not in OBJECT_DICT:
            # The destination object-group is a service object, not network
            logging.debug('had to backtrack to get dstgroup')
            # This test is somewhat ugly
            dstgroup_test = re_match.group(lastidx + 9)
            if dstgroup_test is None:
                raise SyntaxError('Network object %s not found '
                                  '-- possibly corrupt configuration?'
                                  % dstgroup)
            dstgroup = dstgroup_test
        dstiter = yield_object_subnets(dstgroup)
        logging.debug('destination address is object %r', dstgroup)
    else:
        dst = range_to_net(re_range=re_match.group(lastidx + 10),
                           re_host=re_match.group(lastidx + 11),
                           re_net=re_match.group(lastidx + 12),
                           re_mask=re_match.group(lastidx + 13))
        logging.debug("dst = %r", dst)
        dstiter = yield_single_subnet(dst)

    logging.debug('srciter = %r', srciter)
    logging.debug('dstiter = %r', dstiter)
    for srcnet, dstnet in product(srciter, dstiter):
        yield MatchObj('srcdst', SrcDst(srcnet, dstnet))

def extended_acl_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the EXTENDED_ACL_RE regex"""
    logging.debug("got EXTENDED_ACL_RE = %r", re_match.group(lastidx))
    # The only problem with using IPv4Network here is that there is no
    # way to specify that the mask used for this ACL is a wild card
    # host mask, so IPv4Network('0.0.0.0/0.0.0.0') gets interpreted
    # as IPv4Network('0.0.0.0/0') instead of IPv4Network('0.0.0.0/32').
    yield from handle_extended_acl(re_match, lastidx)

def extended_asa_acl_re(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Match the EXTENDED_ASA_ACL_RE regex"""
    logging.debug("got EXTENDED_ASA_ACL_RE = %r", re_match.group(lastidx))
    yield from handle_extended_acl(re_match, lastidx)

def net_or_grp_object_re(re_match: Match[str],
                         lastidx: int) -> Iterable[MatchObj]:
    """Match the NET_OR_GRP_OBJECT_RE regex"""

    logging.debug("got NET_OR_GRP_OBJECT_RE = %r", re_match.group(lastidx))
    # The problem here is that "group-object" can appear in any object
    # type, including service or protocol.  We cannot tell because
    # the current ACL is only stored in parse_config().  Instead,
    # skip yielding any subnets if the object name doesn't exist in
    # the dictionary.
    key = re_match.group(lastidx + 1)
    if key not in OBJECT_DICT:
        return
    # Any expansion here ends up in not only the original place where
    # the subnet was defined, but also in any further expansions.
    # That is, there is no need for recursion here.  This is because
    # the IP subnet is added based on header_obj in the main
    # loop in parse_config().
    for src in yield_object_subnets(key):
        yield MatchObj('srcdst', SrcDst(src, ANY))

def standard_acl_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the STANDARD_ACL_RE regex"""
    logging.debug("got STANDARD_ACL_RE = %r", re_match.group(lastidx))

    aclname = re_match.group(lastidx + 1)
    if aclname is not None:
        logging.debug('aclname = %r', aclname)
        yield MatchObj('aclname', aclname)

    src = range_to_net(re_range=re_match.group(lastidx + 2),
                       re_host=re_match.group(lastidx + 3),
                       re_net=re_match.group(lastidx + 4),
                       re_mask=re_match.group(lastidx + 5))
    logging.debug("src = %r", src)
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))

def twice_nat_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the TWICE_NAT_RE regex"""

    def groupiter(idx: int) -> Iterable[AddrBlock]:
        group = re_match.group(lastidx + idx)
        logging.debug("group = %r", group)
        if group is not None and group in OBJECT_DICT:
            groupiter = yield_object_subnets(group)
        else:
            groupiter = yield_single_subnet(ANY)
        return groupiter

    logging.debug("got TWICE_NAT_RE = %r", re_match.group(lastidx))

    # NAT statements generally have the format SRC1 SRC2 DST1 DST2,
    # so pair up SRC1 and DST1 then SRC2 and DST2.

    srciter = groupiter(1)
    dstiter = groupiter(3)
    for src, dst in product(srciter, dstiter):
        yield MatchObj('srcdst', SrcDst(src, dst))

    # If the nat statement matches "interface", use ANY instead (for now)
    srciter = groupiter(2)
    dstiter = groupiter(4)
    for src, dst in product(srciter, dstiter):
        yield MatchObj('srcdst', SrcDst(src, dst))

def fqdn_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the FQDN_RE regex"""
    logging.debug("got FQDN_RE = %r", re_match.group(lastidx))
    fqdn = re_match.group(lastidx + 1)
    logging.debug("fqdn = %r", fqdn)
    try:
        result = gethostbyname_ex(fqdn)
    except gaierror as err:
        logging.debug("got gaierror = %r", err)
        return
    logging.debug("result = %r", result)
    for ipaddrstr in result[2]:
        logging.debug("ipaddrstr = %r", ipaddrstr)
        yield MatchObj('srcdst', SrcDst(IPv4Network(ipaddrstr), ANY))

def range_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the RANGE_RE regex"""
    logging.debug("got RANGE_RE = %r", re_match.group(lastidx))
    range_start = re_match.group(lastidx + 1)
    range_end = re_match.group(lastidx + 2)
    ip_range_start = IPv4Address(range_start)
    ip_range_end = IPv4Address(range_end)
    logging.debug("ip_range_start = %r", ip_range_start)
    logging.debug("ip_range_end = %r", ip_range_end)
    if ip_range_start > ip_range_end:
        raise SyntaxError('invalid range')
    yield MatchObj('srcdst', SrcDst(Range(ip_range_start, ip_range_end), ANY))

def ip_nat_pool_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the IP_NAT_POOL_RE regex"""
    logging.debug("got IP_NAT_POOL_RE = %r", re_match.group(lastidx))
    start = re_match.group(lastidx + 1)
    end = re_match.group(lastidx + 2)
    msk = re_match.group(lastidx + 3)
    src = addrmasktosubnet(start, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))
    src = addrmasktosubnet(end, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    yield MatchObj('srcdst', SrcDst(src, dst))

def subnet_with_mask_re(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Match the SUBNET_WITH_MASK_RE regex"""
    logging.debug("got SUBNET_WITH_MASK_RE = %r", re_match.group(lastidx))
    net = re_match.group(lastidx + 1)
    msk = re_match.group(lastidx + 2)
    src = addrmasktosubnet(net, msk)
    if src is None:
        subnetlist = list(subnet_re(re_match, lastidx + 1))
        assert len(subnetlist) == 1
        subnet = subnetlist[0]
        logging.debug('successful subnet_re() = %r', subnet)
        yield subnet

        new_index = lastidx + 2
        new_startpos = re_match.start(new_index)
        logging.debug('new_index = %r', new_index)
        logging.debug('re_match.start(new_index) = %r', new_startpos)
        yield MatchObj('position', new_startpos)
    else:
        dst = ANY
        yield MatchObj('srcdst', SrcDst(src, dst))

def subnet_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the SUBNET_RE regex"""
    logging.debug("got SUBNET_RE = %r", re_match.group(lastidx))
    src = safe_IPv4Network(re_match.group(lastidx + 0))
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))

MATCH_RE_TABLE_RAW = {
    "HEADER_RE": header_re,
    "EXTENDED_ASA_ACL_REMARK_RE": extended_asa_acl_remark_re,
    "EXTENDED_ACL_RE": extended_acl_re,
    "EXTENDED_ASA_ACL_RE": extended_asa_acl_re,
    "NET_OR_GRP_OBJECT_RE": net_or_grp_object_re,
    "STANDARD_ACL_RE": standard_acl_re,
    "TWICE_NAT_RE": twice_nat_re,
    "FQDN_RE": fqdn_re,
    "RANGE_RE": range_re,
    "IP_NAT_POOL_RE": ip_nat_pool_re,
    "SUBNET_WITH_MASK_RE": subnet_with_mask_re,
    "SUBNET_RE": subnet_re,
}

def processgroups(n: Iterable[Match[str]]) -> Iterable[MatchObj]:
    """Given an iterable of regex matches (from finditer()), dispatch
    to the helper functions based on the named group that matches.
    This is similar to the parser found in the Python documentation.
    lastgroup is the name of the group that matched, and lastindex is
    the index into the groups where it starts.  The helper functions
    then return an iterable of MatchObj objects, or in the case of
    subnet_with_mask_re(), possibly an integer which indicates the
    position to restart the search."""

    for i, re_match in enumerate(n):
        logging.debug('i = %r, re_match = %r', i, re_match)

        assert bool(re_match)
        assert re_match.lastgroup in MATCH_RE_TABLE_RAW
        assert isinstance(re_match.lastindex, int)
        logging.debug('re_match.lastgroup = %r', re_match.lastgroup)
        logging.debug('re_match.lastindex = %r', re_match.lastindex)
        logging.debug('MATCH_RE_TABLE_RAW[re_match.lastgroup] = %r',
                      MATCH_RE_TABLE_RAW[re_match.lastgroup])
        logging.debug('re_match.group(lastindex + 0) = %r',
                      re_match.group(re_match.lastindex + 0))
        logging.debug('re_match.group(lastindex + 1) = %r',
                      re_match.group(re_match.lastindex + 1))
        logging.debug('re_match.group(lastindex + 2) = %r',
                      re_match.group(re_match.lastindex + 2))

        yield from MATCH_RE_TABLE_RAW[re_match.lastgroup](re_match,
                                                          re_match.lastindex)

def find_regex(match_re: Pattern[str], line: str) -> Iterable[MatchObj]:
    """Iterate through all of the different patterns that can be
    found in a line in the configuration that match an IP address or
    a subnet.  The patterns are dispatched based on the named group
    to helper functions which extract more information.

    If a match type is 'srcdst', return the source and destination
    subnets found.  If the match type is 'position', it indicates that
    the regex matched too far and the value is an integer indicating
    the position to start the search for the next iteration."""

    startpos = 0
    while True:
        logging.debug('finditer with pos = %r', startpos)
        n = match_re.finditer(line, pos=startpos)
        for result in processgroups(n):
            if result.matchtype == 'position':
                assert isinstance(result.obj, int)
                startpos = result.obj
                logging.debug('startpos is %r', startpos)
                break
            logging.debug('result is obj, yielding')
            yield result
        else:
            return

def compile_match_re(args: argparse.Namespace) -> Pattern[str]:
    """Process the MATCH_RE_TABLE_RAW into a regex used for matching.
    If the resolve flag is set, allow matching fqdn statements."""
    assert isinstance(args.resolver, bool)
    match_re_str = '|'.join('(?P<%s>%s)' % (re_str, eval(re_str))
                            for re_str in MATCH_RE_TABLE_RAW
                            if re_str != "FQDN_RE" or args.resolver)
    match_re = re.compile(match_re_str, re.X)
    return match_re

def printline(linenum: int, acl_linenum: Optional[int],
              line: str, args: argparse.Namespace) -> None:
    """Print a line from the configuration"""

    assert isinstance(args.linenumber, bool)
    if not args.linenumber:
        print(line)
        return
    assert isinstance(args.acllines, bool)
    if not args.acllines:
        print("%6d\t%s" % (linenum, line))
        return
    if acl_linenum is None:
        aclline = ''
    else:
        # acl_linenum is relative to linenum
        aclline = '%6d' % (linenum - acl_linenum + 1)
    print("%s\t%s" % (aclline, line))

def getfiledescs(filenames: Collection[str]) -> Iterable[Tuple[Optional[str],
                                                               TextIO]]:
    """Given a list of file names, return each one as an open file descriptor.
    If the list is empty, return stdin."""
    if len(filenames) == 0:
        yield None, sys.stdin
        return
    for filename in filenames:
        logging.debug("filename = %r", filename)
        try:
            filedesc = open(filename)
        except OSError as err:
            print(f'{filename}: {err}', file=sys.stderr)
            continue
        yield filename, filedesc

# XXX this routine is getting overloaded and needs to be broken out
def parse_config(filedesc: TextIO,
                 srcmatch: PrefixRange, dstmatch: PrefixRange, /,
                 logicalor: bool, printit: bool,
                 args: argparse.Namespace) -> None:
    """Parse the configuration and search for lines which match ACLs,
    network objects, or other places IP addresses are used.  If printit
    is True, match the srcmatch and destmatch objects as the networks
    are parsed.  Otherwise, the arguments are ignored and this routine
    is used to capture the networks for all objects in OBJECT_DICT."""

    match_re = compile_match_re(args=args)

    header_last = None
    header_line = None
    current_remark = None
    aclname_last = None
    for linenum, line in enumerate(filedesc, start=1):
        line = line.rstrip('\r\n')
        logging.debug("linenum = %r, line = %r", linenum, line)
        aclname = None
        for matchtype, retval in find_regex(match_re, line):
            logging.debug("matchtype = %r, retval = %r", matchtype, retval)
            if matchtype == 'header':
                assert isinstance(retval, tuple)
                # line_val is entire line, obj_val is object name
                line_val, obj_val = retval
                assert isinstance(line_val, str)
                assert isinstance(obj_val, str)
                logging.debug("find_regex() found new header")
                # New header for network object
                header_line = line_val
                header_obj = obj_val
                header_linenum = linenum
                logging.debug("header_line = %r", header_line)
                logging.debug("header_obj = %r", header_obj)
                # Create the object in the dict
                OBJECT_DICT.setdefault(header_obj, set())
                break
            if matchtype == 'aclname':
                assert isinstance(retval, str)
                aclname = retval
                logging.debug("aclname is %r", aclname)
                header_line = None
                continue

            aclname_linenum: Optional[int]
            if aclname:
                if aclname != aclname_last:
                    # Record the linenum where an ACL starts for the first time
                    aclname_linenum = linenum
            else:
                aclname_linenum = None
            aclname_last = aclname

            if matchtype == 'remark':
                assert isinstance(retval, str)
                current_remark = retval
                current_remark_line = linenum
                logging.debug("current_remark is %r", current_remark)
                logging.debug("current_remark_line is %r", current_remark_line)
                header_line = None
                break
            if matchtype != 'srcdst':
                assert False
            assert isinstance(retval, SrcDst)
            src, dst = retval

            logging.debug('header_line = %r', header_line)
            if header_line is not None:
                logging.debug('header_obj = %r', header_obj)
                # Save the src (address of object) using the object name
                OBJECT_DICT[header_obj].add(src)
            logging.debug('src = %r, srcmatch = %r, dst = %r, dstmatch = %r',
                          src, srcmatch, dst, dstmatch)
            if not printit:
                logging.debug('continue through loop for more networks')
                continue
            # See if the src/dst from the config matches srcmatch/dstmatch
            match_src = match_subnet_prefixrange(src, srcmatch)
            match_dst = match_subnet_prefixrange(dst, dstmatch)
            if match_src or match_dst if logicalor else match_src and match_dst:
                logging.debug('got match')
                if header_line is not None and header_line != header_last:
                    # Header for the ACL changed, so print it now
                    assert header_linenum is not None
                    assert aclname_linenum is None
                    printline(header_linenum, None, header_line, args)
                    header_last = header_line
                # Print remark if one
                if current_remark:
                    # Only print immediately preceding remark
                    assert current_remark_line is not None
                    assert linenum == current_remark_line + 1
                    printline(current_remark_line, aclname_linenum,
                              current_remark, args)
                printline(linenum, aclname_linenum, line, args)
                # Remarks are only relevant for one line only
                current_remark = None
                # Break now, otherwise the same line can be printed more
                # than once
                break
            # No match this time, but iterate for more
            logging.debug('no match')
        else:
            # If the current line is no longer part of an ACL header
            # or object (or any other line that HEADER_RE may match),
            # set the state variable to None.
            if not line.startswith(' '):
                header_line = None
            # Remarks are only relevant for one line only
            current_remark = None

def blockkey(block: AddrBlock) -> IPv4Network:
    """Provide key for sorting objects of type IPv4Network or Range"""
    if isinstance(block, Range):
        return IPv4Network(block.start)
    return block

### Main program

def main() -> None:
    """Main routine"""

    args = getoptions()

    assert isinstance(args.source, PrefixRange)
    assert isinstance(args.destination, PrefixRange)
    srcmatch = args.source
    dstmatch = args.destination

    # Set up logging
    log_format = "%(levelname)s:%(funcName)s:%(lineno)d:%(message)s"
    assert isinstance(args.log_level, int)
    logging.basicConfig(level=args.log_level, format=log_format)

    if args.test:
        assert isinstance(args.test, list)
        testsubnets(ipaddr1_str=args.test[0], ipaddr2_str=args.test[1],
                    minlen_str=args.test[2], maxlen_str=args.test[3])
        sys.exit(0)

    assert isinstance(args.swap, bool)
    if args.swap:
        srcmatch, dstmatch = dstmatch, srcmatch
    assert isinstance(args.duplicate, bool)
    if args.duplicate:
        dstmatch = srcmatch

    logging.debug("srcmatch = %r", srcmatch)
    logging.debug("dstmatch = %r", dstmatch)

    assert isinstance(args.logicalor, bool)
    assert isinstance(args.objects, bool)
    assert isinstance(args.object, (str, type(None)))
    filenames = args.configs
    assert isinstance(filenames, list)
    for n, (filename, filedesc) in enumerate(getfiledescs(filenames)):
        OBJECT_DICT.clear()
        if filename is not None and len(filenames) > 1:
            if n > 0:
                print()
            print(filename + ':')

        parse_config(filedesc, srcmatch, dstmatch, logicalor=args.logicalor,
                     printit=not (args.objects or args.object),
                     args=args)

        if args.objects:
            for k, v in sorted(OBJECT_DICT.items()):
                print(k)
                for x in sorted(v, key=blockkey):
                    print('', x, sep='\t')
        elif args.object:
            if args.object not in OBJECT_DICT:
                print('No such object found')
                continue
            print(args.object)
            for x in sorted(OBJECT_DICT[args.object], key=blockkey):
                print('', x, sep='\t')

if __name__ == '__main__':
    try:
        main()
    except SyntaxError as err:
        sys.exit(f"{sys.argv[0]}: {err}\nUse -h to see help.")

# vim: filetype=python et ts=4 wm=0:
