#!/usr/bin/env python

"""
Find prefix ranges in ACLs from a Cisco router or firewall

Copyright Â© 2022 J. Cowley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License,
or any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

"""
The idea is to find all ACLs which apply to a certain host or
network range.

To do:

* Match ranges (correctly accounting for overlaps, either in whole or part)
"""

import sys
import re
import socket
import struct
import argparse
import logging
from itertools import product
from typing import (Optional, NamedTuple, Union, Sequence, Any, Match,
                    Iterable, Tuple, Dict, List)

# Set some types used for holding data
#
IP = int
# For use when 3.9 is available
#PrefixLength = Annotated[int, ValueRange(0, 32)]
PrefixLength = int

class Subnet(NamedTuple):
    """Represent an IP address or subnet, with prefix length"""
    ip: IP
    prefix: PrefixLength = 32
    def __repr__(self) -> str:
        return 'Subnet(' + subnettoip(self) + ')'

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: Subnet
    ge: PrefixLength
    le: PrefixLength

# Return type for routines that match subnets.  The usual format is a
# tuple with the source and destination subnets.  If a new header is
# detected, then the tuple is (str, None), where the string is the name
# of the header.  In the case that a line should be ignored without
# resetting the header state variables, it is the tuple (None, None).
#
SrcDst = Tuple[Union[Subnet, str, None], Union[Subnet, str, None]]

# Return type for routines that return a SrcDst or a position in the
# string to restart the search using finditer().
#
SrcDstPos = Union[SrcDst, int]

### Network objects

OBJECT_DICT: Dict[str, List[Subnet]] = {}

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

# $1 = IP subnet
# $2 = IP net mask
SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        [ ](?:net)?mask
    )?
    [ ]
    (''' + IP_ADDR + r''')
'''

# $1 = IP subnet
# $2 = prefix length or None
SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/ (\d+)
    )?
'''

# $1 = IP subnet
# $2 = prefix length or None
# $3 = ge value or None
# $4 = le value or None
PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

# $1 = object name
NET_OR_GRP_OBJECT_RE = r'''
    ^
    [ ]*
    (?:
        group-object
        |network-object[ ]object
    )
    [ ]
    (\S+)
'''

# $1 = starting IP address
# $2 = ending IP address
# $3 = net mask
IP_NAT_POOL_RE = r'''
    ^
    [ ]*
    ip[ ]nat[ ]pool[ ]
    \S+[ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    netmask[ ]
    (''' + IP_ADDR + r''')
'''

### ACL matching

# ip access-list extended network-services-in

ACL_HEADER = r'''
    ^
    (?:
        ip[ ]access-list[ ](?:standard|extended)
        | object(?:-group)?[ ]network
        | interface
    )
    [ ](\S+)
'''

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

# $1 = permit/deny
# $2 = any or IP and mask
# $3 = IP
# $4 = subnet mask or None
STANDARD_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ]\d+
    )?
    [ ]
    (permit|deny)[ ]+
    (
        any
        | (''' + IP_ADDR + r''')
          (?:
              [ ] (''' + IP_ADDR + r''')
          )?
    )
    [ ]*
    $
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

# The extra ()s are to make the indexes of the back references the same
# as the EXTENDED_ASA_ACL_RE regex.  This is because both regexes share
# handle_extended_acl(), which uses the same indexes for both regexes.
EXTENDED_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ]\d+
    )?
    [ ]
    (permit|deny)
    [ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:
        [ ] eq [ ] \S+
    |
        [ ] range [ ] \S+ [ ] \S+
    )?
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:[ ]eq[ ]\S+)?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

# $1 = permit|deny
# $2 = protocol
# $3 = protocol object name or None
# $4 = source IP address (all)
# $5 = source host IP address
# $6 = source subnet IP address
# $7 = source netmask
# $8 = source object group name
# $9 = source port object group name
# $10 = destination IP address (all)
# $11= destination host IP address
# $12 = destination subnet IP address
# $13 = destination netmask
# $14 = destination object group name
# $15 = destination port object group name
EXTENDED_ASA_ACL_RE = r'''
    ^
    [ ]*
    access-list[ ]
    \S+[ ]
    extended[ ]
    (permit|deny)[ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim|object(?:-group)?[ ](\S+))[ ]
    (any4?|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' \
        + IP_ADDR + r''')|object(?:-group)?[ ](\S+))
    (?:
        [ ] (?:eq|gt) [ ] \S+
    |
        [ ] range [ ] \S+ [ ] \S+
    |
        [ ]object(?:-group)?[ ](\S+)
    )?
    [ ]
    (any4?|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' \
        + IP_ADDR + r''')|object(?:-group)?[ ](\S+)
    )
    (?:
        [ ] (?:eq|gt) [ ] \S+
        |[ ] range [ ] \S+ [ ] \S+
        |[ ]object(?:-group)?[ ](\S+)
    )?
    (?:[ ]log)?
    (?:[ ]debugging)?
    [ ]*
    $
'''

EXTENDED_IGNORE_RE = r'''
    ^
    [ ]*
    (?:
        (?: access-list[ ]\d+ )? [ ] (?:dynamic|evaluate|remark)[ ]
        | [ ]description[ ]
        | [ ]port-object[ ]
        | [ ]vlan[ ]
        | [ ]nameif[ ]
        | [ ]security-level[ ]
        | [ ]mac-address[ ]
    )
'''

### IP address utility functions

def iptoint(ip: str) -> IP:
    """Convert an IP address as a string into the internal IP format"""
    result: IP = struct.unpack("!I", socket.inet_aton(ip))[0]
    return result

def inttoip(int_: IP) -> str:
    """Convert the internal IP format into an IP address as a string"""
    return socket.inet_ntoa(struct.pack("!I", int_))

def iptosubnet(ip: str) -> Subnet:
    """Convert a string with an IP address and prefix into the internal
    Subnet format"""

    parts = ip.split('/')
    if len(parts) == 1:
        return Subnet(ip=iptoint(parts[0]))
    if len(parts) == 2:
        return Subnet(ip=iptoint(parts[0]), prefix=int(parts[1]))
    raise SyntaxError('subnet must have zero or one slashes')

ANY = iptosubnet("0.0.0.0/0")

def subnettoip(subnet: Subnet) -> str:
    """Convert the internal Subnet format into a string with an IP address
    and prefix"""
    return inttoip(subnet.ip) + '/' + str(subnet.prefix)

def maskof(length: PrefixLength) -> IP:
    """Given a prefix length, return the internal representation IP subnet
    mask.  This mask can be used in bitwise operations with an IP address."""
    return (-1 << (32 - length)) & 0xffffffff

def wildtonetmask(wild: str) -> IP:
    """Convert a wildcard mask as a string into the internal IP format
    of a net mask"""
    wildmask = iptoint(wild)
    netmask = (~wildmask) & 0xffffffff
    return netmask

def netmasktoprefix(mask: IP) -> PrefixLength:
    """Given an internal representation of a subnet mask, return the
    corresponding prefix length."""
    prefix = 32

    # Change netmask to a wildcard so that all of the 1s are on the right.
    # Can't use wildtonetmask here since mask is not a string.
    mask = (~mask) & 0xffffffff
    while mask > 0:
        mask >>= 1
        prefix -= 1
    return prefix

### IP subnet matching

def match_subnet(subnet1: Subnet, subnet2: Subnet,
                 minlen: PrefixLength, maxlen: PrefixLength) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    def subnet_test(addr1: IP, addr2: IP, prefixlen: PrefixLength) -> bool:
        """Test two IPv4 addresses, ADDR1 and ADDR2, for equality when
        normalized to a common prefix length PREFIXLEN."""
        mask = maskof(prefixlen)
        return (addr1 & mask) == (addr2 & mask)

    len1 = subnet1.prefix
    len2 = subnet2.prefix
    containmentp = subnet_test(subnet1.ip, subnet2.ip, min(len1, len2))
    return containmentp and minlen <= len1 <= maxlen

def containment(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Return True if subnet1 is a subnet of subnet2 or vice versa"""
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefix)

def is_contained_in(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, 32)

def matches_exact(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if subnet1 and subnet2 are identical, with the same IP
    and prefix length"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, subnet2.prefix)

def match_subnet_prefixrange(subnet: Subnet, prefix: PrefixRange) -> bool:
    """Test if subnet falls within the subset or superset given
    by the prefix range prefix"""
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Parsing

# XXX redefine to make more sense (e.g., "host" only is used in extended
# acls but not in standard acls)
def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: Optional[str],
                 usewild: bool = True) -> Subnet:
    """Given the parts of a regex matching an ACL in the text,
    convert it to a subnet.  If usewild is set, reverse the bits of
    the re_mask variable.  The regexes that are used in the matching
    are EXTENDED_ACL_RE, EXTENDED_ASA_ACL_RE, and STANDARD_ACL_RE."""
    if re_range.startswith('host '):
        assert re_host is not None
        net = iptoint(re_host)
        mask = 32
    elif re_range in ("any", "any4"):
        net, mask = ANY
    else:
        net = iptoint(re_net)
        if re_mask is None:
            mask = 32
        elif usewild:
            mask = netmasktoprefix(wildtonetmask(re_mask))
        else:
            mask = netmasktoprefix(iptoint(re_mask))
    return Subnet(ip=net, prefix=mask)

# LEN: undefined GE: undefined LE: undefined   ge=32,  le=32
# LEN: undefined GE: undefined LE: defined     ge=32,  le=LE
# LEN: undefined GE: defined   LE: defined     ge=GE,  le=LE
# LEN: undefined GE: defined   LE: undefined   ge=GE,  le=32

# LEN: defined   GE: defined   LE: undefined   ge=GE,  le=LEN
# LEN: defined   GE: defined   LE: defined     ge=GE,  le=LE
# LEN: defined   GE: undefined LE: defined     ge=LEN, le=LE
# LEN: defined   GE: undefined LE: undefined   ge=LEN, le=LEN
def normalize_prefix_lengths(ip: int,
                             length: Optional[int],
                             ge: Optional[int],
                             le: Optional[int]) -> PrefixRange:
    """Fill in the parts of a prefix range using default or derived
    values if those parts are None"""
    if length is None:
        length = 32
    if le is None:
        le = length
        if ge is None:
            ge = length
    elif ge is None:
        ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(Subnet(ip=ip, prefix=length), ge, le)

def safe_int(intstr: Optional[str]) -> Optional[int]:
    """Convert a string to an integer, or None is intstr is None"""
    if intstr is None:
        return None
    return int(intstr)

def parse_prefix_list(arg: str) -> PrefixRange:
    """Given the string representation of a prefix range, convert it
    to a PrefixRange object"""
    re_match = re.match(PREFIX_RE, arg, re.X)
    if not re_match:
        raise SyntaxError('invalid prefix range')
    ip = iptoint(re_match.group(1))
    length = safe_int(re_match.group(2))
    ge = safe_int(re_match.group(3))
    le = safe_int(re_match.group(4))
    return normalize_prefix_lengths(ip, length, ge, le)

def normalized(subnet: Subnet) -> bool:
    """Return True if host portion of the IP address is all zeroes."""
    ip = subnet.ip
    length = subnet.prefix
    return ip & maskof(length) == ip

def addrmasktosubnet(straddr: str, strmask: str) -> Optional[Subnet]:
    """Convert an IP address and a separate IP address used as
    a network mask into a subnet object.  For instance, convert
    "192.168.100.0", "255.255.255.0" into 192.168.100.0/24."""

    logging.debug("straddr = %r", straddr)
    logging.debug("strmask = %r", strmask)
    addr = iptosubnet(straddr)
    mask = iptosubnet(strmask)
    logging.debug("addr = %r", addr)
    logging.debug("mask = %r", mask)
    preflen = netmasktoprefix(mask.ip)
    if maskof(preflen) != mask.ip:
        logging.debug('invalid mask for addr, returning None')
        return None
    logging.debug("preflen = %r", preflen)
    subnet = Subnet(ip=addr.ip, prefix=preflen)
    logging.debug("subnet = %r", subnet)
    return subnet

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    """Conduct various tests on the arguments, used for testing the script"""
    ipaddr1 = iptosubnet(ipaddr1_str)
    ipaddr2 = iptosubnet(ipaddr2_str)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

class PrefixRangeAction(argparse.Action):
    """Customized action for the PrefixLength arguments"""
    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: Union[str, Sequence[Any], None],
                 option_string: Optional[str] = None) -> None:
        """Set the PrefixLength argument"""
        assert isinstance(values, str)
        direction = 'source' if option_string == '-s' else 'destination'
        srcmatch = parse_prefix_list(values)
        if not normalized(srcmatch.subnet):
            print("warning: %s subnet not normalized (%s)"
                  % (direction, subnettoip(srcmatch.subnet)))
        setattr(namespace, self.dest, srcmatch)

def getoptions() -> argparse.Namespace:
    """Parse the command-line options"""

    parser = argparse.ArgumentParser(
        description='Find prefix ranges in ACLs from a Cisco '
                    'router or firewall',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog='''\
A prefix range consists of an IP address (with an optional prefix
length indicating a subnet), and two optional keywords that specify
the minimum and maximum prefix lengths for matches.

    IP[/LENGTH] [ge M] [le N]

The prefix length must be 0 <= length <= 32, and the ge and le
arguments must be 0 <= ge <= le <= 32.

Examples:

1.1.1.1                 Look for a single IP address
1.1.1.0/24              Look for a specific subnet
1.1.1.0/24 le 32        Look for any IP address or subnet in a subnet
1.1.1.0/24 ge 32 le 32  Look for host IP addresses in a subnet
1.1.0.0/16 ge 1 le 32   Look for any IP address or subnet in a subnet
                        and also any supernets except the default route
1.1.1.0/16 ge 0         Look for any supernets of a subnet including
                        the default route
''')

    parser.add_argument('-s', '--source',
                        help='source prefix range to match in configuration',
                        # Match anything by default
                        default=PrefixRange(ANY, ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='SOURCE')
    parser.add_argument('-d', '--destination',
                        help='destination prefix range to match in '
                             'configuration',
                        # Match anything by default
                        default=PrefixRange(ANY, ge=0, le=32),
                        action=PrefixRangeAction,
                        metavar='DESTINATION')
    parser.add_argument('-x', '--reverse',
                        help='swap the source and destinaton addresses\n'
                             '(for convenience)',
                        action='store_true')
    parser.add_argument('-v', '--verbose',
                        help='be verbose',
                        action='store_const',
                        default=logging.INFO,
                        const=logging.DEBUG,
                        dest='log_level')
    parser.add_argument('-t', '--test',
                        nargs=4,
                        help='test the arguments from the command line\n'
                             '(source1, source2, minlen, maxlen)',
                        action='extend')

    return parser.parse_args()

# Parse routines

def acl_header(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the header of a standard or extended ACL"""
    logging.debug("got ACL_HEADER = %r", re_match.group(lastidx))
    # Possible to use group(lastidx + 1) here if just the ACL name is wanted
    yield re_match.group(lastidx + 0), re_match.group(lastidx + 1)

def extended_ignore_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match a line that is part of an object, but should be ignored.
    The main purpose of this is to make sure that current_acl_name
    stays set to the same value while parsing the object.  Once a
    line matches that is not in the object, current_acl_name can set
    to another value or None."""
    logging.debug("got EXTENDED_IGNORE_RE = %r", re_match.group(lastidx))
    # Do not reset current_acl_name (parser is in middle of object)
    yield None, None

def yield_object_subnets(obj_key: str) -> Iterable[Subnet]:
    """Yield the subnets from the network object obj_key"""
    logging.debug('obj_key = %r', obj_key)
    assert obj_key in OBJECT_DICT, obj_key
    for value in OBJECT_DICT[obj_key]:
        logging.debug('obj_key value = %r', value)
        yield value

def yield_single_subnet(subnet: Subnet) -> Iterable[Subnet]:
    """Accept a single argument subnet that will be yielded as needed"""
    yield subnet

def handle_extended_acl(re_match: Match[str], lastidx: int,
                        wildcard: bool) -> Iterable[SrcDst]:
    """Extract values from the various formats for an extended ACL.
    The wildcard variable can be set to True if the subnet mask is
    inversed (such as Cisco routers)."""

    if re_match.group(lastidx + 4).startswith('object'):
        logging.debug('source address is object %r',
                      re_match.group(lastidx + 8))
        srciter = yield_object_subnets(re_match.group(lastidx + 8))
    else:
        logging.debug("wildcard = %r", wildcard)
        src = range_to_net(re_range=re_match.group(lastidx + 4),
                           re_host=re_match.group(lastidx + 5),
                           re_net=re_match.group(lastidx + 6),
                           re_mask=re_match.group(lastidx + 7),
                           usewild=wildcard)
        logging.debug("src = %r", src)
        srciter = yield_single_subnet(src)

    if re_match.group(lastidx + 10).startswith('object'):
        dstgroup = re_match.group(lastidx + 14)
        if dstgroup not in OBJECT_DICT:
            logging.debug('had to backtrack to get dstgroup')
            dstgroup = re_match.group(lastidx + 9)
        dstiter = yield_object_subnets(dstgroup)
        logging.debug('destination address is object %r', dstgroup)
    else:
        dst = range_to_net(re_range=re_match.group(lastidx + 10),
                           re_host=re_match.group(lastidx + 11),
                           re_net=re_match.group(lastidx + 12),
                           re_mask=re_match.group(lastidx + 13),
                           usewild=wildcard)
        logging.debug("dst = %r", dst)
        dstiter = yield_single_subnet(dst)

    logging.debug('srciter = %r', srciter)
    logging.debug('dstiter = %r', dstiter)
    yield from product(srciter, dstiter)

def extended_acl_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the EXTENDED_ACL_RE regex"""
    logging.debug("got EXTENDED_ACL_RE = %r", re_match.group(lastidx))
    yield from handle_extended_acl(re_match, lastidx, wildcard=True)

def extended_asa_acl_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the EXTENDED_ASA_ACL_RE regex"""
    logging.debug("got EXTENDED_ASA_ACL_RE = %r", re_match.group(lastidx))
    yield from handle_extended_acl(re_match, lastidx, wildcard=False)

def net_or_grp_object_re(re_match: Match[str],
                         lastidx: int) -> Iterable[SrcDst]:
    """Match the NET_OR_GRP_OBJECT_RE regex"""

    logging.debug("got NET_OR_GRP_OBJECT_RE = %r", re_match.group(lastidx))
    # The problem here is that "group-object" can appear in any object
    # type, including service or protocol.  We cannot tell because
    # the current ACL is only stored in parse_config().  Instead,
    # skip yielding any subnets if the object name doesn't exist in
    # the dictionary.
    key = re_match.group(lastidx + 1)
    if key not in OBJECT_DICT:
        return
    # Any expansion here ends up in not only the original place where
    # the subnet was defined, but also in any further expansions.
    # That is, there is no need for recursion here.  This is because
    # the IP subnet is added based on current_acl_obj in the main
    # loop in parse_config().
    for src in yield_object_subnets(key):
        yield src, ANY

def standard_acl_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the STANDARD_ACL_RE regex"""
    logging.debug("got STANDARD_ACL_RE = %r", re_match.group(lastidx))
    src = range_to_net(re_range=re_match.group(lastidx + 2),
                       re_host=None,
                       re_net=re_match.group(lastidx + 3),
                       re_mask=re_match.group(lastidx + 4))
    logging.debug("src = %r", src)
    dst = ANY
    yield src, dst

def ip_nat_pool_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the IP_NAT_POOL_RE regex"""
    logging.debug("got IP_NAT_POOL_RE = %r", re_match.group(lastidx))
    start = re_match.group(lastidx + 1)
    end = re_match.group(lastidx + 2)
    msk = re_match.group(lastidx + 3)
    src = addrmasktosubnet(start, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    dst = ANY
    yield src, dst
    src = addrmasktosubnet(end, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    yield src, dst

def subnet_with_mask_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDstPos]:
    """Match the SUBNET_WITH_MASK_RE regex"""
    logging.debug("got SUBNET_WITH_MASK_RE = %r", re_match.group(lastidx))
    net = re_match.group(lastidx + 1)
    msk = re_match.group(lastidx + 2)
    src = addrmasktosubnet(net, msk)
    if src is None:
        subnet = list(subnet_re(re_match, lastidx + 1))
        assert len(subnet) == 1
        logging.debug('successful subnet_re() = %r', subnet[0])
        yield subnet[0]

        new_index = lastidx + 2
        new_startpos = re_match.start(new_index)
        logging.debug('new_index = %r', new_index)
        logging.debug('re_match.start(new_index) = %r', new_startpos)
        yield new_startpos
    else:
        dst = ANY
        yield src, dst

def subnet_re(re_match: Match[str], lastidx: int) -> Iterable[SrcDst]:
    """Match the SUBNET_RE regex"""
    logging.debug("got SUBNET_RE = %r", re_match.group(lastidx))
    src = iptosubnet(re_match.group(lastidx + 0))
    dst = ANY
    yield src, dst

MATCH_RE_TABLE_RAW = {
    "ACL_HEADER": acl_header,
    "EXTENDED_IGNORE_RE": extended_ignore_re,
    "EXTENDED_ACL_RE": extended_acl_re,
    "EXTENDED_ASA_ACL_RE": extended_asa_acl_re,
    "NET_OR_GRP_OBJECT_RE": net_or_grp_object_re,
    "STANDARD_ACL_RE": standard_acl_re,
    "IP_NAT_POOL_RE": ip_nat_pool_re,
    "SUBNET_WITH_MASK_RE": subnet_with_mask_re,
    "SUBNET_RE": subnet_re,
}

MATCH_RE_STR = '|'.join('(?P<%s>%s)' % (re_str, eval(re_str))
                        for re_str in MATCH_RE_TABLE_RAW)
MATCH_RE = re.compile(MATCH_RE_STR, re.X)

def processgroups(n: Iterable[Match[str]]) -> Iterable[SrcDstPos]:
    """Given an iterable of regex matches (from finditer()), dispatch
    to the helper functions based on the named group that matches.
    This is similar to the parser found in the Python documentation.
    lastgroup is the name of the group that matched, and lastindex is
    the index into the groups where it starts.  The helper functions
    then return an iterable of SrcDst objects, or in the case of
    subnet_with_mask_re(), possibly an integer which indicates the
    position to restart the search."""

    for i, re_match in enumerate(n):
        logging.debug('i = %r, re_match = %r', i, re_match)

        assert bool(re_match)
        assert re_match.lastgroup in MATCH_RE_TABLE_RAW
        assert isinstance(re_match.lastindex, int)
        logging.debug('re_match.lastgroup = %r', re_match.lastgroup)
        logging.debug('re_match.lastindex = %r', re_match.lastindex)
        logging.debug('MATCH_RE_TABLE_RAW[re_match.lastgroup] = %r',
                      MATCH_RE_TABLE_RAW[re_match.lastgroup])
        logging.debug('re_match.group(lastindex + 0) = %r',
                      re_match.group(re_match.lastindex + 0))
        logging.debug('re_match.group(lastindex + 1) = %r',
                      re_match.group(re_match.lastindex + 1))
        logging.debug('re_match.group(lastindex + 2) = %r',
                      re_match.group(re_match.lastindex + 2))

        yield from MATCH_RE_TABLE_RAW[re_match.lastgroup](re_match,
                                                          re_match.lastindex)

def find_regex(line: str) -> Iterable[Optional[SrcDst]]:
    """Iterate through all of the different patterns that can be
    found in a line in the configuration that match an IP address or
    a subnet.  The patterns are dispatched based on the named group
    to helper functions which extract more information.

    If a match is found, return the source and destination subnets
    found.  If only a source subnet was found, the destination will
    be 0.0.0.0/0.  As a special case, if source address is a string
    instead, it means a header with an object name was matched.
    Another special case is when both the source and destination
    subnets are set to None, which means to ignore the line and don't
    reset the state variables keeping track of the headers."""

    startpos = 0
    got = False
    while True:
        logging.debug('finditer with pos = %r', startpos)
        n = MATCH_RE.finditer(line, pos=startpos)
        for result in processgroups(n):
            if isinstance(result, int):
                logging.debug('result is int = %r', result)
                startpos = result
                break
            assert isinstance(result, tuple)
            logging.debug('result is obj, yielding')
            got = True
            yield result
        else:
            if not got:
                yield None
            return

def parse_config(srcmatch: PrefixRange, dstmatch: PrefixRange) -> None:
    """Parse the configuration and search for lines which match ACLs,
    network objects, or other places IP addresses are used."""

    last_acl_name = None
    current_acl_name = None
    for line_num, line in enumerate(sys.stdin, start=1):
        line = line.rstrip('\r\n')
        logging.debug("linenum = %r, line = %r", line_num, line)
        for retval in find_regex(line):
            if retval is None:
                logging.debug("find_regex() found no match at all")
                current_acl_name = None
                break
            src, dst = retval
            if src is None:
                # Ignored line
                logging.debug("find_regex() found ignored line")
                break
            if isinstance(src, str):
                assert isinstance(dst, str)
                logging.debug("find_regex() found new header")
                logging.debug("src = %r", src)
                logging.debug("dst = %r", dst)
                # New header for network object
                current_acl_name = src          # src is entire line
                current_acl_obj = dst           # dst is object name
                current_acl_line = line_num
                # Create the object in the dict
                OBJECT_DICT.setdefault(current_acl_obj, [])
                break
            assert isinstance(src, Subnet)
            assert isinstance(dst, Subnet)

            logging.debug('current_acl_name = %r', current_acl_name)
            if current_acl_name is not None:
                logging.debug('current_acl_line = %r', current_acl_line)
                logging.debug('current_acl_obj = %r', current_acl_obj)
                logging.debug('last_acl_name = %r', last_acl_name)
                # Save the src (address of object) using the current object name
                OBJECT_DICT[current_acl_obj].append(src)
            logging.debug('src = %r, srcmatch = %r, dst = %r, dstmatch = %r',
                          src, srcmatch, dst, dstmatch)
            # See if the src/dst from the config matches srcmatch/dstmatch
            if (match_subnet_prefixrange(src, srcmatch) and
                    match_subnet_prefixrange(dst, dstmatch)):
                logging.debug('got match')
                if current_acl_name and (last_acl_name is None
                                         or last_acl_name != current_acl_name):
                    # Header for the ACL changed, so print it now
                    assert current_acl_line is not None
                    print("%5d %s" % (current_acl_line, current_acl_name))
                    last_acl_name = current_acl_name
                print("%5d %s" % (line_num, line))
                # Break now, otherwise the same line can be printed more
                # than once
                break
            # No match this time, but iterate for more
            logging.debug('no match')

### Main program

def main() -> None:
    """Main routine"""

    args = getoptions()
    assert isinstance(args.source, PrefixRange)
    assert isinstance(args.destination, PrefixRange)
    assert isinstance(args.log_level, int)
    assert isinstance(args.reverse, bool)

    srcmatch = args.source
    dstmatch = args.destination

    # Set up logging
    log_format = "%(levelname)s:%(funcName)s:%(lineno)d:%(message)s"
    logging.basicConfig(level=args.log_level, format=log_format)

    if args.test:
        assert isinstance(args.test, list)
        testsubnets(ipaddr1_str=args.test[0], ipaddr2_str=args.test[1],
                    minlen_str=args.test[2], maxlen_str=args.test[3])
        sys.exit(0)

    if args.reverse:
        srcmatch, dstmatch = dstmatch, srcmatch

    logging.debug("srcmatch = %r", srcmatch)
    logging.debug("dstmatch = %r", dstmatch)

    parse_config(srcmatch, dstmatch)

if __name__ == '__main__':
    try:
        main()
    except SyntaxError as err:
        sys.exit(f"{sys.argv[0]}: {err}\nUse -h to see help.")

# vim: filetype=python et ts=4 wm=0:
