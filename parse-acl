#!/usr/bin/env python
#
# Script to find address ranges within a Cisco ACL
#
# The idea is to find all ACLs which apply to a certain host or
# network range.
#
# To do:
#
# * Implement ASA ACLs using the following keywords:
#     object network
#     object service
#     object-group network
#     object-group protocol
#     object-group service
#     access-list
# * Match more than the first IP address on a line (only the first IP
#   address on a line is tested -- all others are ignored).
# * Match ranges (correctly accounting for overlaps, either in whole or part)

import sys
import re
import socket
import struct
import getopt
import logging
from typing import Any, Tuple, Optional

# Set some types used for holding data
Prefix = Tuple[int, int]                # IP address/subnet, prefix length
PrefixRange = Tuple[Prefix, int, int]   # Prefix, ge, le

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/(\d+)
    )?
'''

PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

NETWORK_OBJECT_RE = r'''
    \b
    network-object
    [ ]
'''

NETWORK_OBJECT_HOST_RE = r'''
    ^
    [ ]*
    (?:
    ''' + NETWORK_OBJECT_RE + '''
    )?
    host
    [ ]
    (''' + IP_ADDR + r''')
'''

NETWORK_OBJECT_NETWORK_RE = r'''
    ^
    [ ]*
    ''' + NETWORK_OBJECT_RE + '''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

ROUTE_RE = r'''
    ^
    [ ]*
    route
    [ ]
    \S+
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    \S+
    $
'''

### ACL matching

# Match the header of a standard or extended ACL
ACL_HEADER = r'^(?:ip\ access-list\ (?:standard|extended)|object(?:-group)?\ network)\ (\S+)'

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

STANDARD_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+(any|(''' + IP_ADDR + r')(?:\s+(' + IP_ADDR + r'''))?)
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

EXTENDED_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

EXTENDED_ASA_ACL_RE = r'''
    access-list
    [ ]
    \S+
    [ ]
    extended
    [ ]
    (permit|deny)
    [ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    [ ]
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

EXTENDED_IGNORE_RE = r'(?:(?:access-list\ \d+)?\ (?:dynamic|evaluate|remark)\ |\s+description\ |\s+port-object\ |\s+group-object)'

### IP address utility functions

def iptoint(ip: str) -> int:
    result: int = struct.unpack("!I", socket.inet_aton(ip))[0]
    return result

def inttoip(int_: int) -> str:
    return socket.inet_ntoa(struct.pack("!I", int_))

def iptosubnet(ip: str) -> Prefix:
    try:
        i = ip.index('/')
        mask = int(ip[i + 1:])
        ip = ip[:i]
    except ValueError:
        mask = 32
    ipaddr_bin = iptoint(ip)
    return (ipaddr_bin, mask)

def subnettoip(subnet: Prefix) -> str:
    return inttoip(subnet[0]) + '/' + str(subnet[1])

def maskof(p: int) -> int:
    return (-1 << (32 - p)) & 0xffffffff

def wildtonetmask(wild: str) -> int:
    n = iptoint(wild)
    n = (~n) & 0xffffffff
    return n

def netmasktoprefix(mask: int) -> int:
    prefix = 32

    # Change netmask to a wildcard so that all of the 1s are on the right.
    # Can't use wildtonetmask here since mask is not a string.
    mask = (~mask) & 0xffffffff
    while mask > 0:
        mask >>= 1
        prefix -= 1
    return prefix

### IP subnet matching

def match_subnet(subnet1: Prefix, subnet2: Prefix, minlen: int, maxlen: int) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    def subnet_test(addr1: int, addr2: int, prefixlen: int) -> bool:
        """Test two IPv4 addresses, ADDR1 and ADDR2, for equality when
        normalized to a common prefix length PREFIXLEN."""
        mask = maskof(prefixlen)
        return (addr1 & mask) == (addr2 & mask)

    len1 = subnet1[1]
    len2 = subnet2[1]
    containment = subnet_test(subnet1[0], subnet2[0], min(len1, len2))
    return containment and minlen <= len1 <= maxlen

def containment(subnet1: Prefix, subnet2: Prefix) -> bool:
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: Prefix, subnet2: Prefix) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2[1])

def is_contained_in(subnet1: Prefix, subnet2: Prefix) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2[1], 32)

def matches_exact(subnet1: Prefix, subnet2: Prefix) -> bool:
    return match_subnet(subnet1, subnet2, subnet2[1], subnet2[1])

### Parsing

# XXX redefine to make more sense (e.g., "host" only is used in extended
# acls but not in standard acls)
def range_to_net(re_range: str, re_host: Optional[str], re_net: str, re_mask: str, usewild: bool = True) -> Prefix:
    if re_range.startswith('host '):
        assert re_host is not None
        net = iptoint(re_host)
        mask = 32
    elif re_range == "any" or re_range == "any4":
        net, mask = iptosubnet("0.0.0.0/0")
    else:
        net = iptoint(re_net)
        if usewild:
            mask = netmasktoprefix(wildtonetmask(re_mask))
        else:
            mask = netmasktoprefix(iptoint(re_mask))
    return (net, mask)

# LEN: undefined GE: undefined LE: undefined   ge=32,  le=32
# LEN: undefined GE: undefined LE: defined     ge=32,  le=LE
# LEN: undefined GE: defined   LE: defined     ge=GE,  le=LE
# LEN: undefined GE: defined   LE: undefined   ge=GE,  le=32

# LEN: defined   GE: defined   LE: undefined   ge=GE,  le=32
# LEN: defined   GE: defined   LE: defined     ge=GE,  le=LE
# LEN: defined   GE: undefined LE: defined     ge=LEN, le=LE
# LEN: defined   GE: undefined LE: undefined   ge=LEN, le=LEN
def normalize_prefix_lengths(ip: int, len: Optional[int], ge: Optional[int], le: Optional[int]) -> PrefixRange:
    if len is None:
        len = 32
    if le is None:
        if ge is None:
            ge = le = len
        else:
            le = 32
    elif ge is None:
        ge = len
    return ((ip, len), ge, le)

def safe_int(x: Optional[str]) -> Optional[int]:
    if x is None:
        return None
    return int(x)

def parse_prefix_list(arg: str) -> PrefixRange:
    r = re.match(PREFIX_RE, arg, re.X)
    if not r:
        raise SyntaxError
    ip =  iptoint(r.group(1))
    length = safe_int(r.group(2))
    ge =  safe_int(r.group(3))
    le =  safe_int(r.group(4))
    return normalize_prefix_lengths(ip, length, ge, le)

def normalized(subnet: Prefix) -> bool:
    """Return True if host portion of the IP address is all zeroes."""
    ip = subnet[0]
    length = subnet[1]
    return ip & maskof(length) == ip

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    ipaddr1 = iptosubnet(ipaddr1_str)
    ipaddr2 = iptosubnet(ipaddr2_str)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %s", subnettoip(ipaddr1))
    logging.debug("ipaddr2 = %s", subnettoip(ipaddr2))
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2, minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

### Main program

def main() -> None:
    # Match anything by default
    src_match =   dst_match  = iptosubnet("0.0.0.0/0")
    src_min   =   dst_min    = 0
    src_max   =   dst_max    = 32
    reverse = False
    test = False
    log_level = logging.INFO

    try:
        opts, parseargs = getopt.getopt(sys.argv[1:], 's:d:xvt')
    except getopt.GetoptError as err:
        print("%s: %s" % (sys.argv[0], err))
        sys.exit(1)
    #print "DEBUG:", opts, parseargs
    for opt, arg in opts:
        if opt == '-s':
            # Handle source address
            src_match, src_min, src_max = parse_prefix_list(arg)
            if not normalized(src_match):
                print("warning: src ip not normalized (%s)" % subnettoip(src_match))
        elif opt == '-d':
            # Handle destination address
            dst_match, dst_min, dst_max = parse_prefix_list(arg)
            if not normalized(dst_match):
                print("warning: dst ip not normalized (%s)" % subnettoip(dst_match))
        elif opt == '-x':
            reverse = True
        elif opt == '-v':
            log_level = logging.DEBUG
        elif opt == '-t':
            test = True

    # Set up logging
    logging.basicConfig(level=log_level,
                        format="%(levelname)s:%(funcName)s:%(lineno)d:%(message)s")

    if test:
        if len(parseargs) != 4:
            raise ValueError('not right number of arguments for -t')
        testsubnets(ipaddr1_str=parseargs[0], ipaddr2_str=parseargs[1],
                    minlen_str=parseargs[2], maxlen_str=parseargs[3])
        sys.exit(0)

    # Assert that 0 <= ge <= le <= 32
    # XXX convert asserts to raise SyntaxError
    assert 0 <= src_min, "Must have src  0 <= ge"
    assert src_min <= src_max, "Must have src ge <= le"
    assert src_max <= 32, "Must have src le <= 32"
    assert 0 <= dst_min, "Must have dst  0 <= ge"
    assert dst_min <= dst_max, "Must have dst ge <= le"
    assert dst_max <= 32, "Must have dst le <= 32"

    if reverse:
        src_match, src_min, src_max, dst_match, dst_min, dst_max = \
            dst_match, dst_min, dst_max, src_match, src_min, src_max

    logging.debug("src: %s ge %d le %d" % (subnettoip(src_match), src_min, src_max))
    logging.debug("dst: %s ge %d le %d" % (subnettoip(dst_match), dst_min, dst_max))

    last_acl_name = None
    current_acl_name = None
    current_acl_line = None
    line_num = 0
    for line in sys.stdin:
        line = line.replace('\n', '')
        line_num += 1
        if re.match(ACL_HEADER, line, re.X):
            logging.debug("ACL_HEADER = %r", line)
            current_acl_name = line
            current_acl_line = line_num
            continue
        if re.match(EXTENDED_IGNORE_RE, line, re.X):
            logging.debug("EXTENDED_IGNORE_RE = %r", line)
            continue
        r = re.match(ROUTE_RE, line, re.X)
        if r:
            srcarg = r.group(1)
            msk = r.group(2)
            dstarg = r.group(3)
            #srcarg = iptosubnet(srcarg)
            logging.debug("route %r %r %r", srcarg, msk, dstarg)
            #continue

        r = re.match(EXTENDED_ACL_RE, line, re.X)
        if r:
            wildcard = True
        else:
            r = re.match(EXTENDED_ASA_ACL_RE, line, re.X)
            wildcard = False
        if r:
            # XXX needs to work when both -s and -d specified (logical or)
            # XXX needs error checking
            # XXX $7 and $12 are source or destination ports (if any)
            logging.debug("EXTENDED_ACL_RE, line = %r", line)
            logging.debug("wildcard = %r", wildcard)
            src = range_to_net(r.group(3), r.group(4), r.group(5), r.group(6),
                    usewild=wildcard)
            logging.debug("src = %r", subnettoip(src))
            dst_range = r.group(8)
            if dst_range is None:
                dst_range = "any"
            dst = range_to_net(dst_range, r.group(9), r.group(10), r.group(11),
                    usewild=wildcard)
            logging.debug("dst = %r", subnettoip(dst))
        else:
            r = re.match(STANDARD_ACL_RE, line, re.X)
            if r:
                logging.debug("STANDARD_ACL_RE = %r", line)
                # XXX ugly code
                if r.group(4) is None:
                    src = range_to_net(r.group(2), None, r.group(3), "0.0.0.0")
                    logging.debug("biz = %r", subnettoip(src))
                else:
                    src = range_to_net(r.group(2), None, r.group(3), r.group(4))
                    logging.debug("baz = %r", subnettoip(src))
                dst = iptosubnet("0.0.0.0/0")
                logging.debug("qux = %r", subnettoip(dst))
            else:
                r = re.match(NETWORK_OBJECT_HOST_RE, line, re.X)
                if r:
                    logging.debug("got NETWORK_OBJECT_HOST_RE")
                    src = iptosubnet(r.group(1))
                    dst = iptosubnet("0.0.0.0/0")
                    logging.debug("src = %r", subnettoip(src))
                else:
                    r = re.match(NETWORK_OBJECT_NETWORK_RE, line, re.X)
                    if r:
                        logging.debug("NETWORK_OBJECT_NETWORK_RE, line = %r",
                                      line)
                        pass
                    else:
                        r = re.search(SUBNET_WITH_MASK_RE, line, re.X)
                        if r:
                            pass
                            logging.debug("SUBNET_WITH_MASK_RE, line = %r",
                                          line)
                    if r:
                        a1 = r.group(1)
                        a2 = r.group(2)
                        logging.debug("a1 = %s", a1)
                        logging.debug("a2 = %s", a2)
                        sn1 = iptosubnet(a1)
                        sn2 = iptosubnet(a2)
                        logging.debug("sn1 = %r", sn1)
                        logging.debug("sn2 = %r", sn2)
                        nm2 = netmasktoprefix(sn2[0])
                        if maskof(nm2) != sn2[0]:
                            logging.debug("does not match: %d and %d",
                                          maskof(nm2), sn2[0])
                            continue
                        logging.debug("nm2 = %r", nm2)
                        src = (sn1[0], nm2)
                        dst = iptosubnet("0.0.0.0/0")
                        logging.debug("src = %s", subnettoip(src))
                    else:
                        r = re.search(SUBNET_RE, line, re.X)
                        if r:
                            logging.debug("GOT SUBNET_RE, line = %r", line)
                            src = iptosubnet(r.group(0))
                            dst = iptosubnet("0.0.0.0/0")
                            logging.debug("src = %r", subnettoip(src))
                        else:
                            logging.debug("NO MATCH = %r", line)
                            last_acl_name = None
                            current_acl_name = None
                            current_acl_line = None
                            continue

        if match_subnet(src, src_match, src_min, src_max) and \
           match_subnet(dst, dst_match, dst_min, dst_max):
            if current_acl_name and (last_acl_name is None or last_acl_name != current_acl_name):
                assert current_acl_line is not None
                print("%5d %s" % (current_acl_line, current_acl_name))
                last_acl_name = current_acl_name
            print("%5d %s" % (line_num, line))

if __name__ == '__main__':
    main()

# vim: filetype=python et ts=4 wm=0:
