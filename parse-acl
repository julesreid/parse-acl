#!/usr/bin/env python

"""
Find prefix ranges in ACLs from a Cisco router or firewall

The idea is to find all ACLs which apply to a certain host or
network range.

To do:

• Test cases
• Possibly use ntc-templates to get firewall configuration

Copyright © 2022 J. Cowley

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License,
or any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import re
from ipaddress import (IPv4Network as IPv4Network_orig, IPv4Address,
                       NetmaskValueError)
from socket import gethostbyname_ex, gaierror
import argparse
import logging
from itertools import product
from typing import (Optional, NamedTuple, Union, Sequence, Any, Match,
                    Iterable, Tuple, Dict, Set, Pattern, Literal, Collection,
                    TextIO, Callable, Generator)

class IPv4Network(IPv4Network_orig):
    """Redefine IPv4Network to remove the "/32" for host addresses"""
    def __str__(self) -> str:
        retval = super(IPv4Network, self).__str__()
        # For Python 3.9 and above, use removesuffix()
        if retval.endswith('/32'):
            return retval[:-3]
        return retval

# List of keywords that represent attributes from IPv4Network objects
keyword_list = set(['global', 'link_local', 'loopback', 'multicast',
                    'private', 'reserved', 'unspecified'])
Keyword = str

# Set some types used for holding data
#
# For use when 3.9 is available
#PrefixLength = Annotated[int, ValueRange(0, 32)]
PrefixLength = int

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: IPv4Network
    ge: PrefixLength
    le: PrefixLength
    def __repr__(self) -> str:
        subnet = self.subnet
        prefixlen = subnet.prefixlen
        result = '<PrefixRange ' + str(subnet)
        if self.ge != prefixlen:
            result += f' ge {self.ge}'
        if self.le != prefixlen:
            result += f' le {self.le}'
        result += '>'
        return result

# A match string specified on the command line can either be a keyword
# or a prefix range (abbreviated to an IP address in the simplest case)
MatchType = Union[Keyword, PrefixRange]

class Range(NamedTuple):
    """Represent a range of IP addresses"""
    start: IPv4Address
    end: IPv4Address
    def __str__(self) -> str:
        return str(self.start) + ' - ' + str(self.end)

AddrBlock = Union[IPv4Network, Range]

class SrcDst(NamedTuple):
    """A match object with source and destination networks"""
    src: AddrBlock
    dst: AddrBlock

# Return type for routines that handle match groups.  It is a two-element
# tuple, where the first element is a string identifier that specifies
# the type of the second element.  The usual format is type 'srcdst'
# and a tuple with the source and destination subnets.  If a new header
# is detected, the type is 'header' and a tuple of type (str, str),
# where the first string is the entire line, and the second string
# is the name of the object.  Other types are used for different things.
#
ObjType = Literal['srcdst', 'position', 'header', 'remark', 'aclname',
                  'nat', 'description', 'notfound']
Line = str
ObjName = str
Object = Union[SrcDst,                          # srcdst, nat
               int,                             # position
               Tuple[Line, ObjName],            # header
               str,                             # remark, aclname, description
               None]                            # notfound

class MatchObj(NamedTuple):
    """Generic return type from the matching functions"""
    objtype: ObjType
    obj: Object

### Network objects

# Dictionary of subnets based on the name of the ACL header, the
# network object, or any other identifier from the configuration.
# Each entry contains a list of subnets (or IP addresses) for that
# object, even if some of the entries were derived recursively from
# other objects.
OBJECT_DICT: Dict[str, Set[AddrBlock]] = {}

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

# Allow the two IP addresses to be separated by a slash as well
# as a space.  This allows matching one of the formats allowed by
# IPv4Network.
#
# $1 = IP subnet
# $2 = IP net mask
SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        [ ](?:net)?mask
    )?
    [ /]
    (''' + IP_ADDR + r''')
'''

# $1 = IP subnet
# $2 = prefix length or None
PREFIX_LENGTH = r'\b(?:[0-9]|[12][0-9]|3[0-2])\b'
SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/ (''' + PREFIX_LENGTH + r''')
    )?
'''

# $1 = IP subnet
# $2 = prefix length or None
# $3 = ge value or None
# $4 = le value or None
PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

KEYWORD_RE = r'''
    \b
    (?:''' + '|'.join(keyword for keyword in keyword_list) + r''')
    \b
'''

# $1 = IP address
# $2 = object name
NAME_RE = r'''
    ^
    [ ]*
    name
    [ ](''' + IP_ADDR + r''')
    [ ](\S+)
    (?:
        [ ]description
        [ ].*
    )?
    $
'''

# Only match objects names.  Since a symbolic name can appear after a
# host keyword, we need to make sure it is not an IP address.  If it
# is, it will be matched by SUBNET_RE or SUBNET_WITH_MASK_RE instead.
#
# $1 = object name
NET_OR_GRP_OBJECT_RE = r'''
    ^
    [ ]*
    (?:
        group-object[ ]
        |network-object[ ](?:
                object[ ]
                |host[ ](?!''' + IP_OCTET + ''')
            )
        |host[ ](?!''' + IP_OCTET + r''')
    )
    (\S+)
'''

# $1 = IP address
# $2 = network mask
# $3 = standby IP address or None
IP_ADDRESS_STATEMENT_RE = r'''
    ^
    [ ]*
    ip[ ]address
    [ ](''' + IP_ADDR + ''')
    [ ](''' + IP_ADDR + ''')
    (?:
        [ ]standby
        [ ](''' + IP_ADDR + r''')
    )?
'''

# $1 = starting IP address
# $2 = ending IP address
# $3 = net mask
IP_NAT_POOL_RE = r'''
    ^
    [ ]*
    ip[ ]nat[ ]pool[ ]
    \S+[ ]
    (''' + IP_ADDR + r''')[ ]
    (''' + IP_ADDR + r''')[ ]
    netmask[ ]
    (''' + IP_ADDR + r''')
'''

### ACL matching

# ip access-list extended network-services-in

# $1 = object name
HEADER_RE = r'''
    ^
    (?:
        ip[ ]access-list[ ](?:standard|extended)
        |object(?:-group)?[ ]network
        |interface
    )[ ]
    (\S+)
'''

EXTENDED_ASA_ACL_REMARK_RE = r'''
    ^
    [ ]*
    access-list[ ]
    (\S+)[ ]
    remark[ ]
    .*
'''

# $1 = object name
DESCRIPTION_RE = r'''
    ^
    [ ]* description [ ] (.+)
'''

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

## ASA standard named

# access-list example standard permit host 10.11.12.13

# $1 = ACL name
# $2 = any, host, or IP and mask
# $3 = source host IP address or None
# $4 = IP or None
# $5 = subnet mask or None
STANDARD_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ](?:\d+|(\S+)[ ]standard)
    )?
    [ ]
    (?:permit|deny)[ ]+
    (
        any
        | host[ ](''' + IP_ADDR + r''')
        | (''' + IP_ADDR + r''')
          (?:
              [ ](''' + IP_ADDR + r''')
          )?
    )
    [ ]*
    $
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

# The extra ()s are to make the indexes of the back references the same
# as the EXTENDED_ASA_ACL_RE regex.  This is because both regexes share
# handle_extended_acl(), which uses the same indexes for both regexes.
EXTENDED_ACL_RE = r'''
    ^
    [ ]*
    (?:
        access-list[ ]\d+
    )?
    ()
    [ ]
    (?:permit|deny)[ ]+
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:
        [ ]eq[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
    )?
    ()
    [ ]
    (any|host[ ](''' + IP_ADDR + r')|(' + IP_ADDR + r')[ ](' + IP_ADDR + r'''))
    ()
    (?:[ ]eq[ ]\S+)?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

# $1 = ACL name
# $2 = protocol
# $3 = protocol object name or None
# $4 = source IP address (all)
# $5 = source host IP address
# $6 = source subnet IP address
# $7 = source netmask
# $8 = source object group name
# $9 = source port object group name
# $10 = destination IP address (all)
# $11 = destination host IP address
# $12 = destination subnet IP address
# $13 = destination netmask
# $14 = destination object group name
# $15 = destination port object group name
EXTENDED_ASA_ACL_RE = r'''
    ^
    [ ]*
    access-list[ ]
    (\S+)[ ]
    (?:extended[ ])?
    (?:permit|deny)[ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf
     |pcp|pim|object(?:-group)?[ ](\S+))[ ]
    (
        any4?
        |host[ ](''' + IP_ADDR + r''')
        |(''' + IP_ADDR + r')[ ](' + IP_ADDR + r''')
        |object(?:-group)?[ ](\S+)
        |interface[ ]\S+
    )
    (?:
        [ ](?:eq|gt)[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
        |[ ]object(?:-group)?[ ](\S+)
    )?
    [ ]
    (
        any4?
        |host[ ](''' + IP_ADDR + r''')
        |(''' + IP_ADDR + r')[ ](' + IP_ADDR + r''')
        |object(?:-group)?[ ](\S+)
        |interface[ ]\S+
    )
    (?:
        [ ](?:alternate-address|conversion-error|echo(?:-reply)?
              |information-(?:reply|request)|mask-(?:reply|request)
              |mobile-redirect|parameter-problem|redirect
              |router-(?:advertisement|solicitation)|source-quench
              |time-exceeded|timestamp-(?:reply|request)|traceroute
              |unreachable
           )
        |[ ](?:eq|neq|gt|lt)[ ]\S+
        |[ ]range[ ]\S+[ ]\S+
        |[ ]object(?:-group)?[ ](\S+)
    )?
    (?:[ ]log
       (?:[ ](?:debugging|informational|notifications|warnings|errors|critical
                |alerts|emergencies|[0-7]))?
    )?
    (?:[ ]interval[ ]\d+)?
    (?:[ ]time-range[ ]\S+)?
    (?:[ ]inactive)?
    [ ]*
    $
'''

# $1 = original source IP address
# $2 = translated source IP address
# $3 = original destination IP address
# $4 = translated destination IP address
# $5 = original service ports
# $6 = translation service ports
OBJECT = r'''(\S+)'''
INTF = r'''[a-zA-Z0-9_-]+'''
TWICE_NAT_RE = r'''
    ^
    nat[ ]
    \(''' + INTF + r',' + INTF + r'''\)[ ]
    (?:after-auto[ ])?
    source[ ]
    (?:static|dynamic)[ ]
    (?:any|''' + OBJECT + r''')
    (?:[ ](?:any|interface|''' + OBJECT + r'''))?
    (?:[ ]pat-pool[ ](?:\S+|interface)
        (?:[ ]extended)?
        (?:[ ]flat)?
        (?:[ ]include-reserve)?
        (?:[ ]round-robin)?
        (?:[ ]dns)?
    )?
    (?:
        [ ]+destination[ ]static[ ]
        (?:interface|''' + OBJECT + r''')[ ]
        (?:any|''' + OBJECT + r''')
    )?
    (?:[ ]service[ ]''' + OBJECT + r'''[ ]''' + OBJECT + r''')?
    (?:[ ]net-to-net)?
    (?:[ ]dns)?
    (?:[ ]unidirectional)?
    (?:[ ]no-proxy-arp)?
    (?:[ ]route-lookup)?
    (?:[ ]inactive)?
    (?:[ ]description[ ].*)?
    [ ]*
    $
'''

# $1 = IP address or None
# $2 = network object name or None
OBJECT_NAT_RE = r'''
    ^
    [ ]+
    nat[ ]
    \(''' + INTF + r',' + INTF + r'''\)[ ]
    (?:static|dynamic)
    (?:
        [ ](''' + IP_ADDR + r''') (?:[ ]interface)? (?:[ ]ipv6)?
        |(?:[ ]''' + OBJECT + r''')?
            (?:
                [ ]pat-pool
                (?:
                    [ ]\S+ (?:[ ]interface)? (?:[ ]ipv6)?
                    |[ ]interface (?:[ ]ipv6)?
                )?
                (?:[ ]round-robin)?
                (?:[ ]extended)?
                (?:[ ]flat (?:[ ]include-reserve)?)?
            )?
        |[ ]interface (?:[ ]ipv6)?
    )
    (?:[ ]dns)?
    (?:[ ]no-proxy-arp)?
    (?:[ ]route-lookup)?
    (?:[ ]net-to-net)?
    (?:[ ]service[ ](?: tcp|udp )[ ]\S+[ ]\S+)?
    [ ]*
    $
'''

# $1 = fully-qualified domain name (FQDN)
HOSTNAME = r'(?:[a-zA-Z0-9_-]+\.)*[a-zA-Z0-9_-]+\.?'
FQDN_RE = r'''
    ^
    [ ]+
    fqdn[ ](?:v4[ ])?(''' + HOSTNAME + r''')
'''

# $1 = IP address for range start
# $2 = IP address for range end
RANGE_RE = r'''
    ^
    [ ]+
    range[ ](''' + IP_ADDR + r''')[ ](''' + IP_ADDR + r''')
'''

### IP address utility functions

ANY = IPv4Network("0.0.0.0/0")

def match_subnet(subnet1: IPv4Network, subnet2: IPv4Network,
                 minlen: PrefixLength, maxlen: PrefixLength) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    return subnet1.overlaps(subnet2) and minlen <= subnet1.prefixlen <= maxlen

def containment(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Return True if subnet1 is a subnet of subnet2 or vice versa"""
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefixlen)

def is_contained_in(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefixlen, 32)

def matches_exact(subnet1: IPv4Network, subnet2: IPv4Network) -> bool:
    """Test if subnet1 and subnet2 are identical, with the same IP
    and prefix length"""
    return match_subnet(subnet1, subnet2, subnet2.prefixlen, subnet2.prefixlen)

def match_keyword(subnet: Union[IPv4Network, IPv4Address],
                  keyword: Keyword) -> bool:
    """Return the result of using IPv4Network's attributes for a subnet"""
    retval = getattr(subnet, 'is_' + keyword, None)
    if retval is None:
        assert False, "shouldn't happen"
    assert isinstance(retval, bool)
    return retval

def match_range_keyword(candidate_range: Range, prefix: Keyword) -> bool:
    """Match a range with a match keyword.  Return true as long as
    the start and end addresses match the keyword."""
    candidate_start, candidate_end = candidate_range
    return (match_keyword(candidate_start, prefix)
            and match_keyword(candidate_end, prefix))

def match_range(candidate_range: Range, prefix: MatchType) -> bool:
    """Match a range of addresses against the search prefix.  This is
    equivalent to searching a bunch of host addresses individually.
    Therefore, the match is only considered if the prefix allows
    host addresses.  If so, look for any overlap of the prefix with
    the range."""

    if isinstance(prefix, Keyword):
        return match_range_keyword(candidate_range, prefix)
    # Only match if the match includes host addresses
    if prefix.le != 32:
        return False
    candidate_start, candidate_end = candidate_range
    logging.debug("candidate start = %r, end = %r",
                  candidate_start, candidate_end)
    logging.debug("prefix = %r", prefix)
    prefix_subnet = prefix.subnet
    match_start = IPv4Address(prefix_subnet.network_address)
    match_end = IPv4Address(prefix_subnet.broadcast_address)
    logging.debug("match_start = %r, match_end = %r", match_start, match_end)
    assert candidate_start <= candidate_end
    # Rule out non-overlaps with the range
    if candidate_start < match_start and candidate_end < match_start:
        return False
    if candidate_start > match_end:
        return False
    # What is left is an overlap
    return True

def match_subnet_prefixrange(subnet: AddrBlock, prefix: MatchType) -> bool:
    """Test if subnet falls within the subset or superset given
    by the prefix range prefix"""
    if isinstance(subnet, Range):
        return match_range(subnet, prefix)
    if isinstance(prefix, Keyword):
        return match_keyword(subnet, prefix)
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Option handling

def safe_IPv4Network(ipstr: str) -> IPv4Network:
    """Convert a string to an IPv4Network but issue a warning if the network
    is not normalized (host bits are not zero)"""
    try:
        net = IPv4Network(ipstr, strict=True)
    except ValueError:
        # An exception is raised if the network is not normalized
        net = IPv4Network(ipstr, strict=False)
        print("warning: %s normalized to %s" % (ipstr, net))
    return net

def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: Optional[str]) -> IPv4Network:
    """Given the parts of a regex matching an ACL in the text,
    convert it to a subnet.  The regexes that are used in the matching
    are EXTENDED_ACL_RE, EXTENDED_ASA_ACL_RE, and STANDARD_ACL_RE."""
    if re_range.startswith('host '):
        assert re_host is not None
        net = re_host
    elif re_range in ("any", "any4") or re_range.startswith('interface '):
        net = '0.0.0.0/0'
    elif re_mask is None:
        net = re_net
    else:
        net = re_net + '/' + re_mask
    return safe_IPv4Network(net)

def normalize_prefix_lengths(ip: IPv4Network,
                             ge: Optional[PrefixLength],
                             le: Optional[PrefixLength]) -> PrefixRange:
    """Fill in the parts of a prefix range using default or derived
    values if those parts are None.  Any time the prefix length is not
    given, it defaults to 32.  If ge or le is not given, it defaults
    to the prefix length (except for special cases to match Cisco's
    prefix-list behavior)."""

    length = ip.prefixlen
    if le is None:
        if ge is None:
            ge = le = length
        elif ge > length:
            # Ordinarily generates an error, but allow this special
            # case to match Cisco's behavior (e.g., '10.0.0.0/8 ge 9')
            le = 32
        else:
            le = length
    elif ge is None:
        if le < length:
            # Same special case, but in reverse (e.g., '10.0.0.0/8 le 7')
            ge = 0
        else:
            ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(ip, ge, le)

def safe_int(intstr: Optional[str]) -> Optional[int]:
    """Convert a string to an integer, or None if intstr is None"""
    if intstr is None:
        return None
    return int(intstr)

def parse_prefix_list(arg: str) -> MatchType:
    """Given the string representation of a prefix range or keyword,
    convert it to a MatchType object"""
    re_match = re.match(PREFIX_RE, arg, re.X)
    if not re_match:
        re_match = re.match(KEYWORD_RE, arg, re.X)
        if not re_match:
            raise SyntaxError('invalid match string')
        return re_match.group(0)
    ip = re_match.group(1)
    length = re_match.group(2)
    if length is not None:
        ip += '/' + length
    net = safe_IPv4Network(ip)
    ge = safe_int(re_match.group(3))
    le = safe_int(re_match.group(4))
    return normalize_prefix_lengths(net, ge, le)

def addrmasktosubnet(straddr: str, strmask: str) -> Optional[IPv4Network]:
    """Attempt to convert an IP address and a separate IP address used as
    a network mask into a subnet object.  For instance, convert
    "192.168.100.0", "255.255.255.0" into 192.168.100.0/24.  If the
    two addresses are not related, return None instead."""

    logging.debug("straddr = %r", straddr)
    logging.debug("strmask = %r", strmask)
    net = straddr + '/' + strmask
    logging.debug("net = %r", net)
    try:
        subnet = IPv4Network(net, strict=False)
    except NetmaskValueError:
        logging.debug('invalid mask for addr, returning None')
        return None
    logging.debug("subnet = %r", subnet)
    return subnet

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    """Conduct various tests on the arguments, used for testing the script"""
    ipaddr1 = IPv4Network(ipaddr1_str, strict=False)
    ipaddr2 = IPv4Network(ipaddr2_str, strict=False)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

class PrefixRangeAction(argparse.Action):
    """Customized action for the PrefixLength arguments"""
    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: Union[str, Sequence[Any], None],
                 option_string: Optional[str] = None) -> None:
        """Set the PrefixLength argument"""
        assert isinstance(values, str)
        srcmatchlist: Collection[MatchType]
        srcmatchlist = tuple(parse_prefix_list(prefix_list.strip())
                             for prefix_list in values.split(','))
        setattr(namespace, self.dest, srcmatchlist)

def getoptions() -> argparse.Namespace:
    """Parse the command-line options"""

    parser = argparse.ArgumentParser(
        description='Find prefix ranges in ACLs from a Cisco '
                    'router or firewall',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog='''\
The source or destination can either be a prefix range or a keyword.
A prefix range consists of an IP address (with an optional prefix
length indicating a subnet), and two optional keywords that specify
the minimum and maximum prefix lengths for matches.

    IP[/LENGTH] [ge M] [le N]

The prefix length must be 0 <= length <= 32, and the ge and le
arguments must be 0 <= ge <= le <= 32.

A keyword represent classes of IP addresses such as global or private
RFC 1918 addresses.  The keywords are based on attributes from the
Python ipaddress module.  The complete list is: multicast, private,
global, unspecified, reserved, loopback, and link_local.

Examples:

1.1.1.1                 Look for a single IP address
1.1.1.0/24              Look for a specific subnet
1.1.1.0/24 le 32        Look for any IP address or subnet in a subnet
1.1.1.0/24 ge 32 le 32  Look for host IP addresses in a subnet
1.1.0.0/16 ge 1 le 32   Look for any IP address or subnet in a subnet
                        and also any supernets except the default route
1.1.1.0/16 ge 0         Look for any supernets of a subnet including
                        the default route
private                 Look for private RFC 1918 addresses
''')

    parser.add_argument('-s', '--source',
                        help='source to match in configuration',
                        # Match anything by default
                        default=(PrefixRange(ANY, ge=0, le=32),),
                        action=PrefixRangeAction,
                        metavar='SOURCE')
    parser.add_argument('-d', '--destination',
                        help='destination to match in configuration',
                        # Match anything by default
                        default=(PrefixRange(ANY, ge=0, le=32),),
                        action=PrefixRangeAction,
                        metavar='DESTINATION')
    parser.add_argument('-x', '--swap',
                        help='swap the source and destinaton addresses\n'
                             '(for convenience)',
                        action='store_true')
    parser.add_argument('-p', '--transpose',
                        help='add another matching sequence with the source\n'
                             'and destination addresses swapped',
                        action='store_true')
    parser.add_argument('-v', '--verbose',
                        help='be verbose',
                        action='store_const',
                        default=logging.INFO,
                        const=logging.DEBUG,
                        dest='log_level')
    parser.add_argument('-t', '--test',
                        nargs=4,
                        help='test the arguments from the command line\n'
                             '(source1, source2, minlen, maxlen)',
                        action='extend')
    object_group = parser.add_mutually_exclusive_group()
    object_group.add_argument('-o', '--show-object',
                              help='show the IP addresses for the object',
                              dest='object')
    object_group.add_argument('-O', '--show-objects',
                              help='show the IP addresses for all objects',
                              action='store_true',
                              dest='objects')
    parser.add_argument('-l', '--resolve',
                        help=('process fqdn statements by resolving DNS\n'
                              '(if not set, substitute 0.0.0.1/32 instead,\n'
                              'and if set, substitute 0.0.0.2/32 for errors)'),
                        action='store_true',
                        dest='resolver')
    parser.add_argument('-n', '--line-number',
                        help=('prefix each line of output with the\n'
                              '1-based line number within its input file'),
                        action='store_true',
                        dest='linenumber')
    parser.add_argument('-a', '--acl-lines',
                        help='prefix ACLs with the 1-based line number',
                        action='store_true',
                        dest='acllines')
    parser.add_argument('configs',
                        nargs='*',
                        help='configuration file(s) to read')

    args = parser.parse_args()

    if not args.linenumber and args.acllines:
        parser.error('cannot have -a without -n')

    return args

### Match group handling

def header_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the header of a standard or extended ACL or object"""
    logging.debug("got HEADER_RE = %r", re_match.group(lastidx))
    # Possible to use group(lastidx + 1) here if just the ACL name is wanted
    yield MatchObj('header', (re_match.group(lastidx + 0),
                              re_match.group(lastidx + 1)))

def extended_asa_acl_remark_re(re_match: Match[str],
                               lastidx: int) -> Iterable[MatchObj]:
    """Match the remark statement of a standard or extended ACL"""
    logging.debug("got EXTENDED_ASA_ACL_REMARK_RE = %r",
                  re_match.group(lastidx))
    logging.debug('aclname = %r', re_match.group(lastidx + 1))
    yield MatchObj('aclname', re_match.group(lastidx + 1))
    remark = re_match.group(lastidx)
    yield MatchObj('remark', remark)

def description_re(re_match: Match[str],
                   lastidx: int) -> Iterable[MatchObj]:
    """Match the description statement in an object"""
    logging.debug("got DESCRIPTION_RE = %r", re_match.group(lastidx))
    logging.debug('description = %r', re_match.group(lastidx + 1))
    yield MatchObj('description', re_match.group(lastidx + 1))

def yield_object_subnets(obj_key: str) -> Iterable[AddrBlock]:
    """Yield the subnets from the network object obj_key"""
    logging.debug('obj_key = %r', obj_key)
    if obj_key not in OBJECT_DICT:
        raise SyntaxError('Network object %s not found '
                          '-- possibly corrupt configuration?'
                          % obj_key)
    for value in OBJECT_DICT[obj_key]:
        logging.debug('obj_key value = %r', value)
        yield value

def yield_single_subnet(subnet: IPv4Network) -> Iterable[AddrBlock]:
    """Accept a single argument subnet that will be yielded as needed"""
    yield subnet

def handle_extended_acl(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Extract values from the various formats for an extended ACL."""

    aclname = re_match.group(lastidx + 1)
    if aclname:
        logging.debug('aclname = %r', aclname)
        yield MatchObj('aclname', aclname)

    if re_match.group(lastidx + 4).startswith('object'):
        logging.debug('source address is object %r',
                      re_match.group(lastidx + 8))
        srciter = yield_object_subnets(re_match.group(lastidx + 8))
    else:
        src = range_to_net(re_range=re_match.group(lastidx + 4),
                           re_host=re_match.group(lastidx + 5),
                           re_net=re_match.group(lastidx + 6),
                           re_mask=re_match.group(lastidx + 7))
        logging.debug("src = %r", src)
        srciter = yield_single_subnet(src)

    if re_match.group(lastidx + 10).startswith('object'):
        dstgroup = re_match.group(lastidx + 14)
        logging.debug('dstgroup = %r', dstgroup)
        if dstgroup not in OBJECT_DICT:
            # The destination object-group is a service object, not network
            logging.debug('had to backtrack to get dstgroup')
            # This test is somewhat ugly
            dstgroup_test = re_match.group(lastidx + 9)
            if dstgroup_test is None:
                raise SyntaxError('Network object %s not found '
                                  '-- possibly corrupt configuration?'
                                  % dstgroup)
            dstgroup = dstgroup_test
        dstiter = yield_object_subnets(dstgroup)
        logging.debug('destination address is object %r', dstgroup)
    else:
        dst = range_to_net(re_range=re_match.group(lastidx + 10),
                           re_host=re_match.group(lastidx + 11),
                           re_net=re_match.group(lastidx + 12),
                           re_mask=re_match.group(lastidx + 13))
        logging.debug("dst = %r", dst)
        dstiter = yield_single_subnet(dst)

    logging.debug('srciter = %r', srciter)
    logging.debug('dstiter = %r', dstiter)
    for srcnet, dstnet in product(srciter, dstiter):
        yield MatchObj('srcdst', SrcDst(srcnet, dstnet))

def extended_acl_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the EXTENDED_ACL_RE regex"""
    logging.debug("got EXTENDED_ACL_RE = %r", re_match.group(lastidx))
    # The only problem with using IPv4Network here is that there is no
    # way to specify that the mask used for this ACL is a wild card
    # host mask, so IPv4Network('0.0.0.0/0.0.0.0') gets interpreted
    # as IPv4Network('0.0.0.0/0') instead of IPv4Network('0.0.0.0/32').
    yield from handle_extended_acl(re_match, lastidx)

def extended_asa_acl_re(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Match the EXTENDED_ASA_ACL_RE regex"""
    logging.debug("got EXTENDED_ASA_ACL_RE = %r", re_match.group(lastidx))
    yield from handle_extended_acl(re_match, lastidx)

def name_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the NAME_RE regex"""
    logging.debug("got NAME_RE = %r", re_match.group(lastidx))
    entire_line = re_match.group(lastidx + 0)
    ip_address_str = re_match.group(lastidx + 1)
    name = re_match.group(lastidx + 2)
    yield MatchObj('header', (entire_line, name))
    ip_address = IPv4Network(ip_address_str)
    logging.debug("ip_address = %r", ip_address)
    yield MatchObj('srcdst', SrcDst(ip_address, ANY))

def net_or_grp_object_re(re_match: Match[str],
                         lastidx: int) -> Iterable[MatchObj]:
    """Match the NET_OR_GRP_OBJECT_RE regex"""

    logging.debug("got NET_OR_GRP_OBJECT_RE = %r", re_match.group(lastidx))
    # The problem here is that "group-object" can appear in any object
    # type, including service or protocol.  We cannot tell because
    # the current ACL is only stored in parse_config().  Instead,
    # skip yielding any subnets if the object name doesn't exist in
    # the dictionary.
    key = re_match.group(lastidx + 1)
    if key not in OBJECT_DICT:
        return
    # Any expansion here ends up in not only the original place where
    # the subnet was defined, but also in any further expansions.
    # That is, there is no need for recursion here.  This is because
    # the IP subnet is added based on header_obj in the main
    # loop in header_coroutine().
    for src in yield_object_subnets(key):
        yield MatchObj('srcdst', SrcDst(src, ANY))

def standard_acl_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the STANDARD_ACL_RE regex"""
    logging.debug("got STANDARD_ACL_RE = %r", re_match.group(lastidx))

    aclname = re_match.group(lastidx + 1)
    if aclname is not None:
        logging.debug('aclname = %r', aclname)
        yield MatchObj('aclname', aclname)

    src = range_to_net(re_range=re_match.group(lastidx + 2),
                       re_host=re_match.group(lastidx + 3),
                       re_net=re_match.group(lastidx + 4),
                       re_mask=re_match.group(lastidx + 5))
    logging.debug("src = %r", src)
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))

def twice_nat_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the TWICE_NAT_RE regex"""

    def groupiter(idx: int) -> Iterable[AddrBlock]:
        group = re_match.group(lastidx + idx)
        logging.debug("group = %r", group)
        if group is not None and group in OBJECT_DICT:
            groupiter = yield_object_subnets(group)
        else:
            groupiter = yield_single_subnet(ANY)
        return groupiter

    logging.debug("got TWICE_NAT_RE = %r", re_match.group(lastidx))

    # NAT statements generally have the format SRC1 SRC2 DST1 DST2,
    # so pair up SRC1 and DST1 then SRC2 and DST2.

    srciter = groupiter(1)
    dstiter = groupiter(3)
    for src, dst in product(srciter, dstiter):
        yield MatchObj('srcdst', SrcDst(src, dst))

    # If the nat statement matches "interface", use ANY instead (for now)
    srciter = groupiter(2)
    dstiter = groupiter(4)
    for src, dst in product(srciter, dstiter):
        yield MatchObj('nat', SrcDst(src, dst))

def object_nat_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the OBJECT_NAT_RE regex"""
    logging.debug("got OBJECT_NAT_RE = %r", re_match.group(lastidx))

    ipaddr = re_match.group(lastidx + 1)
    network_object = re_match.group(lastidx + 2)
    if ipaddr is not None:
        assert network_object is None
        yield MatchObj('nat', SrcDst(IPv4Network(ipaddr), ANY))
        return
    if network_object is None:
        # pat-pool is being used
        yield MatchObj('nat', SrcDst(ANY, ANY))
        return
    logging.debug("have object nat with network_object = %r", network_object)
    # If the nat statement matches "interface", use ANY instead (for now)
    if network_object == 'interface':
        yield MatchObj('nat', SrcDst(ANY, ANY))
        return
    if network_object not in OBJECT_DICT:
        return
    for src in yield_object_subnets(network_object):
        yield MatchObj('nat', SrcDst(src, ANY))

def fqdn_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the FQDN_RE regex"""
    logging.debug("got FQDN_RE = %r", re_match.group(lastidx))
    fqdn = re_match.group(lastidx + 1)
    logging.debug("fqdn = %r", fqdn)
    try:
        result = gethostbyname_ex(fqdn)
    except gaierror as err:
        logging.debug("got gaierror = %r", err)
        yield MatchObj('srcdst', SrcDst(IPv4Network('0.0.0.2/32'), ANY))
        return
    logging.debug("result = %r", result)
    for ipaddrstr in result[2]:
        logging.debug("ipaddrstr = %r", ipaddrstr)
        yield MatchObj('srcdst', SrcDst(IPv4Network(ipaddrstr), ANY))

def fqdn_re_no_lookup(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the FQDN_RE regex but do not resolve address"""
    logging.debug("got FQDN_RE = %r", re_match.group(lastidx))
    fqdn = re_match.group(lastidx + 1)
    logging.debug("fqdn = %r", fqdn)
    # Return an address in "this network" to substitute for the unresolved FQDN
    yield MatchObj('srcdst', SrcDst(IPv4Network('0.0.0.1/32'), ANY))

def range_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the RANGE_RE regex"""
    logging.debug("got RANGE_RE = %r", re_match.group(lastidx))
    range_start = re_match.group(lastidx + 1)
    range_end = re_match.group(lastidx + 2)
    ip_range_start = IPv4Address(range_start)
    ip_range_end = IPv4Address(range_end)
    logging.debug("ip_range_start = %r", ip_range_start)
    logging.debug("ip_range_end = %r", ip_range_end)
    if ip_range_start > ip_range_end:
        raise SyntaxError('invalid range')
    yield MatchObj('srcdst', SrcDst(Range(ip_range_start, ip_range_end), ANY))

def ip_address_statement_re(re_match: Match[str],
                            lastidx: int) -> Iterable[MatchObj]:
    """Match the IP_ADDRESS_STATEMENT_RE regex"""
    logging.debug("got IP_ADDRESS_STATEMENT_RE = %r", re_match.group(lastidx))
    ipaddr = re_match.group(lastidx + 1)
    netmask = re_match.group(lastidx + 2)
    standby = re_match.group(lastidx + 3)
    subnet = addrmasktosubnet(ipaddr, netmask)
    if subnet is None:
        raise SyntaxError('invalid mask for address')
    # Yield the subnet
    yield MatchObj('srcdst', SrcDst(subnet, ANY))
    # Yield the IP address as a host network
    yield MatchObj('srcdst', SrcDst(IPv4Network(ipaddr), ANY))
    # Yield the standby IP address as a host network if it exists
    if standby:
        yield MatchObj('srcdst', SrcDst(IPv4Network(standby), ANY))

def ip_nat_pool_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the IP_NAT_POOL_RE regex"""
    logging.debug("got IP_NAT_POOL_RE = %r", re_match.group(lastidx))
    start = re_match.group(lastidx + 1)
    end = re_match.group(lastidx + 2)
    msk = re_match.group(lastidx + 3)
    src = addrmasktosubnet(start, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))
    src = addrmasktosubnet(end, msk)
    if src is None:
        raise SyntaxError('invalid mask for address')
    yield MatchObj('srcdst', SrcDst(src, dst))

def subnet_with_mask_re(re_match: Match[str],
                        lastidx: int) -> Iterable[MatchObj]:
    """Match the SUBNET_WITH_MASK_RE regex"""
    logging.debug("got SUBNET_WITH_MASK_RE = %r", re_match.group(lastidx))
    net = re_match.group(lastidx + 1)
    msk = re_match.group(lastidx + 2)
    # Attempt to parse net and msk as an IP subnet and subnet mask
    src = addrmasktosubnet(net, msk)
    if src is None:
        # net and msk are separate IP addresses, so first yield net
        subnetlist = list(subnet_re(re_match, lastidx + 1))
        assert len(subnetlist) == 1
        subnet = subnetlist[0]
        logging.debug('successful subnet_re() = %r', subnet)
        yield subnet

        # msk is problematic because the regex in find_regex() has
        # already matched this IP address, and it could be the start
        # of another net/msk.  Instead, signal to find_regex() to parse
        # again starting at this position.
        new_index = lastidx + 2
        new_startpos = re_match.start(new_index)
        logging.debug('new_index = %r', new_index)
        logging.debug('re_match.start(new_index) = %r', new_startpos)
        yield MatchObj('position', new_startpos)
    else:
        # Parse of IP subnet and mask was successful
        dst = ANY
        yield MatchObj('srcdst', SrcDst(src, dst))

def subnet_re(re_match: Match[str], lastidx: int) -> Iterable[MatchObj]:
    """Match the SUBNET_RE regex"""
    logging.debug("got SUBNET_RE = %r", re_match.group(lastidx))
    src = safe_IPv4Network(re_match.group(lastidx + 0))
    dst = ANY
    yield MatchObj('srcdst', SrcDst(src, dst))

# Table of regular expressions that match components in the
# configuration, and the functions which extract the values from them.
# The table is indexed by the functions, and prepare_regexes() later
# uses this table to make two further tables for parsing.
MATCH_RE_TABLE_RAW = {
    header_re: HEADER_RE,
    extended_asa_acl_remark_re: EXTENDED_ASA_ACL_REMARK_RE,
    description_re: DESCRIPTION_RE,
    extended_acl_re: EXTENDED_ACL_RE,
    extended_asa_acl_re: EXTENDED_ASA_ACL_RE,
    name_re: NAME_RE,
    net_or_grp_object_re: NET_OR_GRP_OBJECT_RE,
    standard_acl_re: STANDARD_ACL_RE,
    twice_nat_re: TWICE_NAT_RE,
    object_nat_re: OBJECT_NAT_RE,
    fqdn_re: FQDN_RE,
    range_re: RANGE_RE,
    ip_address_statement_re: IP_ADDRESS_STATEMENT_RE,
    ip_nat_pool_re: IP_NAT_POOL_RE,
    subnet_with_mask_re: SUBNET_WITH_MASK_RE,
    subnet_re: SUBNET_RE,
}

### Miscellanous

def processgroups(n: Iterable[Match[str]]) -> Iterable[MatchObj]:
    """Given an iterable of regex matches (from finditer()), dispatch
    to the helper functions based on the named group that matches.
    This is similar to the parser found in the Python documentation.
    lastgroup is the name of the group that matched, and lastindex is
    the index into the groups where it starts.  The helper functions
    then return an iterable of MatchObj objects, or in the case of
    subnet_with_mask_re(), possibly an integer which indicates the
    position to restart the search."""

    for i, re_match in enumerate(n):
        logging.debug('i = %r, re_match = %r', i, re_match)

        assert bool(re_match)
        assert re_match.lastgroup in MATCH_FUNCS
        assert isinstance(re_match.lastindex, int)
        logging.debug('re_match.lastgroup = %r', re_match.lastgroup)
        logging.debug('re_match.lastindex = %r', re_match.lastindex)
        logging.debug('MATCH_FUNCS[re_match.lastgroup] = %r',
                      MATCH_FUNCS[re_match.lastgroup])
        logging.debug('re_match.group(lastindex + 0) = %r',
                      re_match.group(re_match.lastindex + 0))
        logging.debug('re_match.group(lastindex + 1) = %r',
                      re_match.group(re_match.lastindex + 1))
        logging.debug('re_match.group(lastindex + 2) = %r',
                      re_match.group(re_match.lastindex + 2))

        yield from MATCH_FUNCS[re_match.lastgroup](re_match,
                                                   re_match.lastindex)

def find_regex(match_re: Pattern[str], line: str) -> Iterable[MatchObj]:
    """Iterate through all of the different patterns that can be
    found in a line in the configuration that match an IP address or
    a subnet.  The patterns are dispatched based on the named group
    to helper functions which extract more information.

    If a match type is 'srcdst', return the source and destination
    subnets found.  If the match type is 'position', it indicates that
    the regex matched too far and the value is an integer indicating
    the position to start the search for the next iteration."""

    startpos = 0
    while True:
        logging.debug('finditer with pos = %r', startpos)
        n = match_re.finditer(line, pos=startpos)
        for result in processgroups(n):
            if result.objtype == 'position':
                assert isinstance(result.obj, int)
                startpos = result.obj
                logging.debug('startpos is %r', startpos)
                break
            logging.debug('result is obj, yielding')
            yield result
        else:
            return

def compile_match_re() -> Pattern[str]:
    """Process the MATCH_RE_TABLE_RAW into a regex used for matching.
    See the Python documentation for writing a tokenizer to see how
    this is put together.

    https://docs.python.org/3/library/re.html#writing-a-tokenizer
    """

    # The function names and regexes from MATCH_RE_TABLE_RAW are
    # converted into named groups and combined into a single, master
    # regular expression that combines all of the regular expressions.
    match_re_str = '|'.join('(?P<%s>%s)' % (re_func.__name__, re_value)
                            for re_func, re_value in MATCH_RE_TABLE_RAW.items())
    match_re = re.compile(match_re_str, re.X)
    return match_re

SEEN_LINENUMS: Set[int] = set()

def printline(linenum: int, acl_linenum: Optional[int],
              line: str, args: argparse.Namespace) -> None:
    """Print a line from the configuration"""

    logging.debug("linenum = %r, acl_linenum = %r, line = %r",
                  linenum, acl_linenum, line)
    if linenum in SEEN_LINENUMS:
        return
    SEEN_LINENUMS.add(linenum)
    assert isinstance(args.linenumber, bool)
    if not args.linenumber:
        print(line)
        return
    assert isinstance(args.acllines, bool)
    if not args.acllines:
        # This is the same format for line numbers as "cat -n"
        print("%6d\t%s" % (linenum, line))
        return
    if acl_linenum is None:
        aclline = ''
    else:
        # acl_linenum is relative to linenum
        aclline = '%6d' % (linenum - acl_linenum + 1)
    print("%s\t%s" % (aclline, line))

def getfiledescs(filenames: Collection[str]) -> Iterable[Tuple[Optional[str],
                                                               TextIO]]:
    """Given a list of file names, return each one as an open file descriptor.
    If the list is empty, return stdin."""
    if len(filenames) == 0:
        yield None, sys.stdin
        return
    for filename in filenames:
        logging.debug("filename = %r", filename)
        try:
            filedesc = open(filename)
        except OSError as err:
            print(f'{filename}: {err}', file=sys.stderr)
            continue
        with filedesc:
            yield filename, filedesc

### State machines

LineNum = int
CoroutineSend = Tuple[ObjType, Object, bool, LineNum, Line]

HeaderYield = Optional[Tuple[LineNum, Line]]
RemarkYield = Optional[Tuple[LineNum, Line]]
ACLNameYield = Optional[LineNum]
ObjectNATYield = Optional[Tuple[LineNum, Line]]
DescriptionYield = Optional[Tuple[LineNum, Line]]

HeaderType = Generator[HeaderYield, CoroutineSend, None]
RemarkType = Generator[RemarkYield, CoroutineSend, None]
ACLNameType = Generator[ACLNameYield, CoroutineSend, None]
ObjectNATType = Generator[ObjectNATYield, CoroutineSend, None]
DescriptionType = Generator[DescriptionYield, CoroutineSend, None]

class ParserState:
    """Contain the state for parsing a pair of PrefixRanges objects.
    If the user has specified multiple prefix ranges to parse, there
    will be one instance of this class for each permutation of source
    and destination prefix ranges.  This is necessary because a single
    state machine cannot be used for multiple ranges, otherwise a
    range overwrites the state used by another range and the right
    lines are not output."""

    def __init__(self, srcmatch: MatchType, dstmatch: MatchType) -> None:
        self.srcmatch = srcmatch
        self.dstmatch = dstmatch
        self._gen_init()

    def __repr__(self) -> str:
        return ('<ParserState object at %s, '
                'srcmatch = %r, dstmatch = %r>'
                % (hex(id(self)), self.srcmatch, self.dstmatch))

    def _gen_init(self) -> None:
        """Create the generator objects that will be used as state
        machines to parse the header lines, remarks, and ACL start
        lines."""
        self._header_gen = header_coroutine()
        self._remark_gen = remark_coroutine()
        self._aclname_gen = aclname_coroutine()
        self._objectnat_gen = objectnat_coroutine()
        self._description_gen = description_coroutine()
        assert next(self._header_gen) is None
        assert next(self._remark_gen) is None
        assert next(self._aclname_gen) is None
        assert next(self._objectnat_gen) is None
        assert next(self._description_gen) is None

    def gen_send(self, matchobj: MatchObj, matched: bool, linenum: int,
                 line: str) -> Tuple[HeaderYield, RemarkYield, ACLNameYield,
                                     ObjectNATYield, DescriptionYield]:
        """Send the same match object and other data to the generator
        objects that are part of the parser state."""
        logging.debug("matchobj = %r, matched = %r, linenum = %r, line = %r",
                      matchobj, matched, linenum, line)
        send_arg = (matchobj.objtype, matchobj.obj, matched, linenum, line)
        ret_seq: Tuple[Union[HeaderYield, RemarkYield, ACLNameYield,
                             ObjectNATYield, DescriptionYield], ...]
        ret_seq = (self._header_gen.send(send_arg),)
        ret_seq += (self._remark_gen.send(send_arg),)
        ret_seq += (self._aclname_gen.send(send_arg),)
        ret_seq += (self._objectnat_gen.send(send_arg),)
        ret_seq += (self._description_gen.send(send_arg),)
        return ret_seq

def header_coroutine() -> HeaderType:
    """Receive match objects and other data from parse_config(),
    keep state, and yield the most recent header for a matching subnet."""
    header_line = None
    header_last = None
    yieldval = None
    while True:
        logging.debug("yielding %r", yieldval)
        # Yields either None or a tuple with the line number and line
        objtype, obj, matched, linenum, line = (yield yieldval)
        if objtype == 'header':
            assert isinstance(obj, tuple)
            # line_val is entire line, obj_val is object name
            line_val, obj_val = obj
            assert isinstance(line_val, str)
            assert isinstance(obj_val, str)
            logging.debug("found new header for network object")
            header_line = line_val
            header_obj = obj_val
            header_linenum = linenum
            logging.debug("header_line = %r", header_line)
            logging.debug("header_obj = %r", header_obj)
            # Create the object in the dict
            OBJECT_DICT.setdefault(header_obj, set())
            yieldval = None
            continue

        if objtype not in ('srcdst', 'nat'):
            yieldval = None
            continue

        assert isinstance(obj, SrcDst)

        # If the current line is no longer part of an ACL header
        # or object (or any other line that HEADER_RE may match),
        # set the state variable to None.  A "name" statement is
        # treated specially since it doesn't start with a space.
        logging.debug("line starts with space = %r", line.startswith(' '))
        if not line.startswith(' ') and not line.startswith('name '):
            header_line = None
            yieldval = None
            continue

        logging.debug('header_line = %r', header_line)
        # Do not include 'nat' subnets in the object
        if header_line is not None and objtype != 'nat':
            logging.debug('saving header_obj %r with %r', header_obj, obj.src)
            # Save the src (address of object) using the object name
            OBJECT_DICT[header_obj].add(obj.src)

        if matched:
            if header_line is not None and header_line != header_last:
                # Header for the ACL changed, so print it now
                assert header_linenum is not None
                yieldval = header_linenum, header_line
                header_last = header_line
            else:
                yieldval = None

def remark_coroutine() -> RemarkType:
    """Receive match objects and other data from parse_config(),
    keep state, and yield the most recent remark for a matching subnet."""
    current_remark_line = None
    yieldval = None
    while True:
        logging.debug("yielding %r", yieldval)
        # Yields either None or a tuple with the line number and line
        objtype, obj, matched, linenum, _ = (yield yieldval)

        if objtype == 'remark':
            assert isinstance(obj, str)
            current_remark_line = linenum
            current_remark = obj
            got_aclname = False
            logging.debug("current_remark_line is %r", current_remark_line)
            logging.debug("current_remark is %r", current_remark)
            yieldval = None
            continue

        if current_remark_line:
            if linenum == current_remark_line + 1:
                # The requirement here is that a 'remark' match type
                # is only good for 'aclname' on a line that immediately
                # follows.  If that is met, then start yielding for any
                # 'srcdst' match types that are on the same line.
                if objtype == 'aclname':
                    got_aclname = True
                    continue
                if objtype == 'srcdst' and got_aclname and matched:
                    logging.debug("set yieldval")
                    yieldval = current_remark_line, current_remark
                    continue
                continue
            if linenum == current_remark_line:
                continue
            current_remark_line = None

        # None of the criteria met, so reset everything
        yieldval = None

def aclname_coroutine() -> ACLNameType:
    """Receive match objects and other data from parse_config(),
    keep state, and yield the line number of where an ACL starts.
    This is used for the -a option to provide relative line numbers."""
    aclname = None
    aclname_last = None
    yieldval = None
    last_linenum = None
    while True:
        logging.debug("yielding %r", yieldval)
        # Yields either None or a line number
        objtype, obj, _, linenum, _ = (yield yieldval)

        # Each new line resets aclname in case it is not an ACL.
        # If it is, aclname will get set again from objtype 'aclname'.
        if linenum != last_linenum:
            aclname = None
            last_linenum = linenum

        if objtype == 'aclname':
            assert isinstance(obj, str)
            aclname = obj
            logging.debug("aclname is %r", aclname)
            yieldval = None
            continue

        if aclname:
            if aclname != aclname_last:
                # Record the linenum where an ACL starts for the first time
                aclname_linenum: Optional[int] = linenum
                aclname_last = aclname
        else:
            aclname_linenum = None
        yieldval = aclname_linenum

def objectnat_coroutine() -> ObjectNATType:
    """Receive match objects and other data from parse_config(), keep
    state, and yield the most recent header for a matching subnet.
    The matched parameter says that srcmatch matched one of the subnets
    from the original object, even though it doesn't appear anywhere
    in the NAT object of the same name."""

    header_line = None
    yieldval = None
    while True:
        logging.debug("yielding %r", yieldval)
        # Yields either None or a tuple with the line number and line
        objtype, obj, matched, linenum, line = (yield yieldval)
        logging.debug("objtype = %r, obj = %r, matched = %r, "
                      "linenum = %r, line = %r",
                      objtype, obj, matched, linenum, line)
        if objtype == 'header' and matched:
            header_line = line
            header_linenum = linenum
            # There is a match, so print the header line
            yieldval = header_linenum, header_line
            continue
        if objtype == 'nat' and header_line:
            # Now print the NAT that corresponds to the original address
            yieldval = linenum, line
            continue
        header_line = None
        yieldval = None

def description_coroutine() -> DescriptionType:
    """Receive match objects and other data from parse_config(), keep
    keep state, and yield the line number of any matched "description"
    statement."""

    description = None
    yieldval = None
    got_match = None
    while True:
        logging.debug("yielding %r", yieldval)
        # Yields either None or a tuple with the line number and line
        objtype, obj, matched, linenum, line = (yield yieldval)
        logging.debug("objtype = %r, obj = %r, matched = %r, "
                      "linenum = %r, line = %r",
                      objtype, obj, matched, linenum, line)

        if objtype == 'description':
            description = line
            description_line = linenum
        elif objtype == 'srcdst' and matched:
            got_match = True

        # The description line can come before or after the match,
        # so check that both have been received
        if description and got_match:
            yieldval = description_line, description
            description = None
            got_match = None
            continue

        logging.debug("line starts with space = %r", line.startswith(' '))
        if not line.startswith(' '):
            description = None
            got_match = None

        yieldval = None

def prefixinobject(objname: str, prefix: MatchType) -> bool:
    """Determine if a prefix range 'prefix' matches any of the subnets
    in the object named by 'objname'."""
    logging.debug("objname = %r, prefix = %r", objname, prefix)
    if objname not in OBJECT_DICT:
        return False
    logging.debug("OBJECT_DICT[objname] = %r", OBJECT_DICT[objname])
    for subnet in OBJECT_DICT[objname]:
        if match_subnet_prefixrange(subnet, prefix):
            return True
    return False

def parser_matchobj(parser: ParserState, matchobj: MatchObj,
                    args: argparse.Namespace, linenum: int, line: str) -> bool:
    """Core engine for handling match objects.  This sends data to
    the state objects held in the ParserState object, and prepares
    to print lines based on the yielded results."""

    if args.objects or args.object:
        # If not printing anything, send the info anyway to the state machines
        # to gather object information
        logging.debug('continue through loop for more networks')
        parser.gen_send(matchobj, False, linenum, line)
        return False

    srcmatch = parser.srcmatch
    dstmatch = parser.dstmatch
    logging.debug("srcmatch = %r, dstmatch = %r", srcmatch, dstmatch)
    objtype, retval = matchobj
    logging.debug("objtype = %r, retval = %r", objtype, retval)
    if objtype in ('srcdst', 'nat'):
        # See if the src/dst from the config matches srcmatch/dstmatch
        assert isinstance(retval, SrcDst)
        src, dst = retval
        logging.debug('src = %r, srcmatch = %r, dst = %r, dstmatch = %r',
                      src, srcmatch, dst, dstmatch)
        matched = (match_subnet_prefixrange(src, srcmatch)
                   and match_subnet_prefixrange(dst, dstmatch))
    elif (objtype == 'header' and not isinstance(dstmatch, Keyword)
          and dstmatch.ge == 0):
        # Search the header for IP subnets that might match srcmatch,
        # but only if we are not searching for dstmatch also.
        assert isinstance(retval, tuple)
        objname = retval[1]
        assert isinstance(objname, str)
        matched = prefixinobject(objname, srcmatch)
    else:
        matched = False
    logging.debug("matched = %r", matched)

    (header_result, remark_result, acl_linenum, objectnat,
     description) = parser.gen_send(matchobj, matched, linenum, line)
    logging.debug('header_result = %r', header_result)
    logging.debug('remark_result = %r', remark_result)
    logging.debug('acl_linenum = %r', acl_linenum)
    logging.debug('objectnat = %r', objectnat)
    logging.debug('description = %r', description)

    if remark_result:
        printline(remark_result[0], acl_linenum, remark_result[1], args)
    if header_result:
        printline(header_result[0], acl_linenum, header_result[1], args)
    if objectnat:
        printline(objectnat[0], acl_linenum, objectnat[1], args)
    if description:
        printline(description[0], acl_linenum, description[1], args)
    if matched:
        printline(linenum, acl_linenum, line, args)

    # Return True if a line matched, otherwise the same line can be
    # printed more than once
    return matched

def iterparsers(parserlist: Collection[ParserState], matchobj: MatchObj,
                args: argparse.Namespace, linenum: int, line: str) -> bool:
    """Iterate through the parsers listed in parserlist and call
    parser_matchobj for each one.  If True is returned, this indicates
    a line was printed, so we can short circuit and go to the next
    line."""

    for parser in parserlist:
        if parser_matchobj(parser, matchobj, args, linenum, line):
            return True
    return False

def create_parse_list(srcmatchlist: Collection[MatchType],
                      dstmatchlist: Collection[MatchType],
                      args: argparse.Namespace) -> Collection[ParserState]:
    """Create the parser list by creating an instance of the
    ParserState class for each permutation of source and destination
    prefix ranges.  If the transpose option is given, also create
    another parse list to match with the source and destination
    addresses swapped."""

    retval = tuple(ParserState(srcmatch, dstmatch)
                   for srcmatch, dstmatch
                   in product(srcmatchlist, dstmatchlist))
    if args.transpose:
        retval += tuple(ParserState(dstmatch, srcmatch)
                        for srcmatch, dstmatch
                        in product(srcmatchlist, dstmatchlist))
    return retval

def parse_config(filedesc: TextIO,
                 srcmatchlist: Collection[MatchType],
                 dstmatchlist: Collection[MatchType], /,
                 match_re: Pattern[str],
                 args: argparse.Namespace) -> None:
    """Given a file descriptor and a collection of source and
    destination prefix ranges, parse the configuration and search
    for lines which match ACLs, network objects, or other places IP
    addresses are used.  """

    parserlist = create_parse_list(srcmatchlist, dstmatchlist, args)
    logging.debug("parserlist = %r", parserlist)
    for linenum, line in enumerate(filedesc, start=1):
        line = line.rstrip('\r\n')
        logging.debug("linenum = %r, line = %r", linenum, line)
        found_regex = False
        for matchobj in find_regex(match_re, line):
            found_regex = True
            # If iterparsers returns True, it means a line was printed
            if iterparsers(parserlist, matchobj, args, linenum, line):
                break
        else:
            if not found_regex:
                # Not found but send since it might be the end of a section
                for parser in parserlist:
                    parser.gen_send(MatchObj('notfound', None), False,
                                    linenum, line)

def blockkey(block: AddrBlock) -> IPv4Network:
    """Provide key for sorting objects of type IPv4Network or Range"""
    if isinstance(block, Range):
        return IPv4Network(block.start)
    return block

def prepare_regexes(args: argparse.Namespace) -> Pattern[str]:
    """Prepare the MATCH_FUNCS and match_re regular expressions which
    are used by parse_args().  They only need to be compiled once."""

    # Convert MATCH_RE_TABLE_RAW to a mapping of regex group name to function
    for key in MATCH_RE_TABLE_RAW:
        MATCH_FUNCS[key.__name__] = key

    # As a special case, replace the default FQDN parser if no -l option
    if not args.resolver:
        MATCH_FUNCS['fqdn_re'] = fqdn_re_no_lookup

    return compile_match_re()

### Main program

MATCH_FUNCS: Dict[str, Callable[[Match[str], int], Iterable[MatchObj]]] = {}

def main() -> None:
    """Main routine"""

    args = getoptions()

    assert isinstance(args.source, tuple)
    assert isinstance(args.destination, tuple)
    #for pr in args.source: assert isinstance(pr, MatchType)
    #for pr in args.destination: assert isinstance(pr, MatchType)
    srcmatch = args.source
    dstmatch = args.destination

    # Set up logging
    log_format = "%(levelname)s:%(funcName)s:%(lineno)d:%(message)s"
    assert isinstance(args.log_level, int)
    logging.basicConfig(level=args.log_level, format=log_format)

    if args.test:
        assert isinstance(args.test, list)
        testsubnets(ipaddr1_str=args.test[0], ipaddr2_str=args.test[1],
                    minlen_str=args.test[2], maxlen_str=args.test[3])
        sys.exit(0)

    assert isinstance(args.swap, bool)
    if args.swap:
        srcmatch, dstmatch = dstmatch, srcmatch

    logging.debug("srcmatch = %r", srcmatch)
    logging.debug("dstmatch = %r", dstmatch)

    match_re = prepare_regexes(args)

    assert isinstance(args.objects, bool)
    assert isinstance(args.object, (str, type(None)))
    filenames = args.configs
    assert isinstance(filenames, list)
    for n, (filename, filedesc) in enumerate(getfiledescs(filenames)):
        OBJECT_DICT.clear()
        SEEN_LINENUMS.clear()
        if filename is not None and len(filenames) > 1:
            if n > 0:
                print()
            print(filename + ':')

        parse_config(filedesc, srcmatch, dstmatch, match_re, args=args)

        if args.objects:
            for k, v in sorted(OBJECT_DICT.items()):
                print(k)
                for x in sorted(v, key=blockkey):
                    print('', x, sep='\t')
        elif args.object:
            if args.object not in OBJECT_DICT:
                print('No such object found')
                continue
            print(args.object)
            for x in sorted(OBJECT_DICT[args.object], key=blockkey):
                print('', x, sep='\t')

if __name__ == '__main__':
    try:
        main()
    except SyntaxError as err:
        sys.exit(f"{sys.argv[0]}: {err}\nUse -h to see help.")

# vim: filetype=python et ts=4 wm=0:
