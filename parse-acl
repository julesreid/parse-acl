#!/usr/bin/env python
#
# Script to find address ranges within a Cisco ACL
#
# The idea is to find all ACLs which apply to a certain host or
# network range.
#
# To do:
#
# * Implement ASA ACLs using the following keywords:
#     object network
#     object service
#     object-group network
#     object-group protocol
#     object-group service
#     access-list
# * Match more than the first IP address on a line (only the first IP
#   address on a line is tested -- all others are ignored).
# * Match ranges (correctly accounting for overlaps, either in whole or part)

import sys
import re
import socket
import struct
import getopt
import logging
from typing import Tuple, Optional, NamedTuple

class Subnet(NamedTuple):
    """Represent an IP address or subnet, with prefix length"""
    ip: int
    prefix: int = 32
    def __repr__(self) -> str:
        return 'Subnet(' + subnettoip(self) + ')'

class PrefixRange(NamedTuple):
    """Represent a subnet, with minimum (ge) and maximum (le) prefix lengths"""
    subnet: Subnet
    ge: int
    le: int

# Set some types used for holding data
Ge = int
Le = int

### IP address, subnet and prefix list matching

IP_OCTET = r'\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b'
IP_ADDR = IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET + r'\.' + IP_OCTET

SUBNET_WITH_MASK_RE = r'''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

SUBNET_RE = r'''
    (''' + IP_ADDR + r''')
    (?:
        \/(\d+)
    )?
'''

PREFIX_RE = r'''
    ^
    ''' + SUBNET_RE + r'''
    (?: \s+ ge \s+ (\d+) )?
    (?: \s+ le \s+ (\d+) )?
    $
'''

NETWORK_OBJECT_RE = r'''
    \b
    network-object
    [ ]
'''

NETWORK_OBJECT_HOST_RE = r'''
    ^
    [ ]*
    (?:
    ''' + NETWORK_OBJECT_RE + '''
    )?
    host
    [ ]
    (''' + IP_ADDR + r''')
'''

NETWORK_OBJECT_NETWORK_RE = r'''
    ^
    [ ]*
    ''' + NETWORK_OBJECT_RE + '''
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
'''

ROUTE_RE = r'''
    ^
    [ ]*
    route
    [ ]
    \S+
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    (''' + IP_ADDR + r''')
    [ ]
    \S+
    $
'''

### ACL matching

# Match the header of a standard or extended ACL
ACL_HEADER = (r'^(?:ip\ access-list\ (?:standard|extended)'
              r'|object(?:-group)?\ network)\ (\S+)')

## Standard numbered

# access-list 23 permit 10.1.3.15
# access-list 23 permit 10.2.19.224 0.0.0.31
# access-list 23 permit 10.2.127.0 0.0.0.255
# access-list 23 permit 10.10.0.0 0.0.255.255

## Standard named

# ip access-list standard mgmt-access
#  permit 10.1.3.15
#  permit 10.2.19.224 0.0.0.31
#  permit 10.2.127.0 0.0.0.255
#  permit 10.2.3.0 0.0.0.255
#  permit 10.10.21.0 0.0.0.255

STANDARD_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+(any|(''' + IP_ADDR + r')(?:\s+(' + IP_ADDR + r'''))?)
'''

## Extended numbered

# access-list 100 remark From HL
# access-list 100 permit ip 10.5.40.64 0.0.0.31 any
#                 time-range hlc-rate-limiting
# access-list 101 remark To HL
# access-list 101 permit ip any 10.5.40.64 0.0.0.31
#                 time-range hlc-rate-limiting
#
# access-list 100 permit udp host 10.15.2.8 any eq echo log

## Extended named

# ip access-list extended network-services-in
#  permit udp host 0.0.0.0 eq bootpc host 255.255.255.255 eq bootps log
#  deny   udp any eq bootpc any eq bootps log
#  permit ip any any

EXTENDED_ACL_RE = r'''
    (?:
        access-list
        \s+\d+
    )?
    \s+
    (permit|deny)
    \s+
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

## Extended ASA (NOTE: not a wildcard mask)

# access-list Internal_nat0_outbound extended
#             permit ip 172.16.11.48 255.255.255.240 host 172.16.11.25

EXTENDED_ASA_ACL_RE = r'''
    access-list
    [ ]
    \S+
    [ ]
    extended
    [ ]
    (permit|deny)
    [ ]
    (\d+|ip|icmp|tcp|udp|ahp|eigrp|esp|gre|igmp|ipinip|nos|ospf|pcp|pim)
    [ ]
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' \
        + IP_ADDR + r'''))
    (?:
        \s+ eq \s+ (\S+)
    |
        \s+ range \s+ \S+ \s+ \S+
    )?
    \s+
    (any4?|host\s+(''' + IP_ADDR + r')|(' + IP_ADDR + r')\s+(' \
        + IP_ADDR + r'''))
    (?:\s+eq\s+(\S+))?
'''

EXTENDED_IGNORE_RE = (r'(?:(?:access-list\ \d+)?\ (?:dynamic|evaluate|remark)'
                      r'\ |\s+description\ |\s+port-object\ |\s+group-object)')

### IP address utility functions

def iptoint(ip: str) -> int:
    result: int = struct.unpack("!I", socket.inet_aton(ip))[0]
    return result

def inttoip(int_: int) -> str:
    return socket.inet_ntoa(struct.pack("!I", int_))

def iptosubnet(ip: str) -> Subnet:
    try:
        i = ip.index('/')
        mask = int(ip[i + 1:])
        ip = ip[:i]
    except ValueError:
        mask = 32
    ipaddr_bin = iptoint(ip)
    return Subnet(ip=ipaddr_bin, prefix=mask)

def subnettoip(subnet: Subnet) -> str:
    return inttoip(subnet.ip) + '/' + str(subnet.prefix)

def maskof(p: int) -> int:
    return (-1 << (32 - p)) & 0xffffffff

def wildtonetmask(wild: str) -> int:
    n = iptoint(wild)
    n = (~n) & 0xffffffff
    return n

def netmasktoprefix(mask: int) -> int:
    prefix = 32

    # Change netmask to a wildcard so that all of the 1s are on the right.
    # Can't use wildtonetmask here since mask is not a string.
    mask = (~mask) & 0xffffffff
    while mask > 0:
        mask >>= 1
        prefix -= 1
    return prefix

### IP subnet matching

def match_subnet(subnet1: Subnet, subnet2: Subnet,
                 minlen: int, maxlen: int) -> bool:
    """Given two subnets, SUBNET1 and SUBNET2, test whether SUBNET1 is
    either a superset or subset of SUBNET2 that falls within the prefix
    length range between MINLEN and MAXLEN."""
    def subnet_test(addr1: int, addr2: int, prefixlen: int) -> bool:
        """Test two IPv4 addresses, ADDR1 and ADDR2, for equality when
        normalized to a common prefix length PREFIXLEN."""
        mask = maskof(prefixlen)
        return (addr1 & mask) == (addr2 & mask)

    len1 = subnet1.prefix
    len2 = subnet2.prefix
    containmentp = subnet_test(subnet1.ip, subnet2.ip, min(len1, len2))
    return containmentp and minlen <= len1 <= maxlen

def containment(subnet1: Subnet, subnet2: Subnet) -> bool:
    return match_subnet(subnet1, subnet2, 0, 32)

def contains(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network (a.addr,a.mask) CONTAINS (b.addr,b.mask)

    Caveat: Don't assume that a or b is normalised."""
    return match_subnet(subnet1, subnet2, 0, subnet2.prefix)

def is_contained_in(subnet1: Subnet, subnet2: Subnet) -> bool:
    """Test if network SUBNET1 IS CONTAINED IN SUBNET2"""
    return match_subnet(subnet1, subnet2, subnet2.prefix, 32)

def matches_exact(subnet1: Subnet, subnet2: Subnet) -> bool:
    return match_subnet(subnet1, subnet2, subnet2.prefix, subnet2.prefix)

def match_subnet_prefixrange(subnet: Subnet, prefix: PrefixRange) -> bool:
    return match_subnet(subnet, prefix.subnet, prefix.ge, prefix.le)

### Parsing

# XXX redefine to make more sense (e.g., "host" only is used in extended
# acls but not in standard acls)
def range_to_net(re_range: str, re_host: Optional[str],
                 re_net: str, re_mask: str, usewild: bool = True) -> Subnet:
    if re_range.startswith('host '):
        assert re_host is not None
        net = iptoint(re_host)
        mask = 32
    elif re_range in ("any", "any4"):
        net, mask = iptosubnet("0.0.0.0/0")
    else:
        net = iptoint(re_net)
        if usewild:
            mask = netmasktoprefix(wildtonetmask(re_mask))
        else:
            mask = netmasktoprefix(iptoint(re_mask))
    return Subnet(ip=net, prefix=mask)

# LEN: undefined GE: undefined LE: undefined   ge=32,  le=32
# LEN: undefined GE: undefined LE: defined     ge=32,  le=LE
# LEN: undefined GE: defined   LE: defined     ge=GE,  le=LE
# LEN: undefined GE: defined   LE: undefined   ge=GE,  le=32

# LEN: defined   GE: defined   LE: undefined   ge=GE,  le=32
# LEN: defined   GE: defined   LE: defined     ge=GE,  le=LE
# LEN: defined   GE: undefined LE: defined     ge=LEN, le=LE
# LEN: defined   GE: undefined LE: undefined   ge=LEN, le=LEN
def normalize_prefix_lengths(ip: int,
                             length: Optional[int],
                             ge: Optional[int],
                             le: Optional[int]) -> PrefixRange:
    if length is None:
        length = 32
    if le is None:
        if ge is None:
            ge = le = length
        else:
            le = 32
    elif ge is None:
        ge = length
    if not 0 <= length <= 32:
        raise SyntaxError('must have 0 <= length <= 32')
    if not 0 <= ge <= le <= 32:
        raise SyntaxError('must have 0 <= ge <= le <= 32')
    return PrefixRange(Subnet(ip=ip, prefix=length), ge, le)

def safe_int(x: Optional[str]) -> Optional[int]:
    if x is None:
        return None
    return int(x)

def parse_prefix_list(arg: str) -> PrefixRange:
    r = re.match(PREFIX_RE, arg, re.X)
    if not r:
        raise SyntaxError('invalid prefix range')
    ip = iptoint(r.group(1))
    length = safe_int(r.group(2))
    ge = safe_int(r.group(3))
    le = safe_int(r.group(4))
    return normalize_prefix_lengths(ip, length, ge, le)

def normalized(subnet: Subnet) -> bool:
    """Return True if host portion of the IP address is all zeroes."""
    ip = subnet.ip
    length = subnet.prefix
    return ip & maskof(length) == ip

def testsubnets(ipaddr1_str: str, ipaddr2_str: str,
                minlen_str: str, maxlen_str: str) -> None:
    ipaddr1 = iptosubnet(ipaddr1_str)
    ipaddr2 = iptosubnet(ipaddr2_str)
    minlen = int(minlen_str)
    maxlen = int(maxlen_str)
    assert 0 <= minlen <= maxlen <= 32, (minlen, maxlen)

    logging.debug("ipaddr1 = %r", ipaddr1)
    logging.debug("ipaddr2 = %r", ipaddr2)
    logging.debug("minlen = %d", minlen)
    logging.debug("maxlen = %d", maxlen)

    results = (("match_subnet", match_subnet(ipaddr1, ipaddr2,
                                             minlen, maxlen)),
               ("containment", containment(ipaddr1, ipaddr2)),
               ("contains", contains(ipaddr1, ipaddr2)),
               ("is_contained_in", is_contained_in(ipaddr1, ipaddr2)),
               ("matches_exact", matches_exact(ipaddr1, ipaddr2)))
    for name, result in results:
        print("%-22s  %s" % (name, result))

### Main program

def main() -> None:
    # Match anything by default
    srcip = dstip = PrefixRange(iptosubnet("0.0.0.0/0"), ge=0, le=32)
    reverse = False
    test = False
    log_level = logging.INFO

    try:
        opts, parseargs = getopt.getopt(sys.argv[1:], 's:d:xvt')
    except getopt.GetoptError as err:
        print("%s: %s" % (sys.argv[0], err))
        sys.exit(1)
    #print "DEBUG:", opts, parseargs
    for opt, arg in opts:
        if opt == '-s':
            # Handle source address
            srcip = parse_prefix_list(arg)
            if not normalized(srcip.subnet):
                print("warning: src ip not normalized (%s)"
                      % subnettoip(srcip.subnet))
        elif opt == '-d':
            # Handle destination address
            dstip = parse_prefix_list(arg)
            if not normalized(dstip.subnet):
                print("warning: dst ip not normalized (%s)"
                      % subnettoip(dstip.subnet))
        elif opt == '-x':
            reverse = True
        elif opt == '-v':
            log_level = logging.DEBUG
        elif opt == '-t':
            test = True

    # Set up logging
    logging.basicConfig(level=log_level,
                        format="%(levelname)s:%(funcName)s:"
                               "%(lineno)d:%(message)s")

    if test:
        if len(parseargs) != 4:
            raise ValueError('not right number of arguments for -t')
        testsubnets(ipaddr1_str=parseargs[0], ipaddr2_str=parseargs[1],
                    minlen_str=parseargs[2], maxlen_str=parseargs[3])
        sys.exit(0)

    if reverse:
        srcip, dstip = dstip, srcip

    logging.debug("src: %r", srcip)
    logging.debug("dst: %r", dstip)

    last_acl_name = None
    current_acl_name = None
    current_acl_line = None
    line_num = 0
    for line in sys.stdin:
        line = line.replace('\n', '')
        line_num += 1
        if re.match(ACL_HEADER, line, re.X):
            logging.debug("ACL_HEADER = %r", line)
            current_acl_name = line
            current_acl_line = line_num
            continue
        if re.match(EXTENDED_IGNORE_RE, line, re.X):
            logging.debug("EXTENDED_IGNORE_RE = %r", line)
            continue
        r = re.match(ROUTE_RE, line, re.X)
        if r:
            srcarg = r.group(1)
            msk = r.group(2)
            dstarg = r.group(3)
            #srcarg = iptosubnet(srcarg)
            logging.debug("route %r %r %r", srcarg, msk, dstarg)
            #continue

        r = re.match(EXTENDED_ACL_RE, line, re.X)
        if r:
            wildcard = True
        else:
            r = re.match(EXTENDED_ASA_ACL_RE, line, re.X)
            wildcard = False
        if r:
            # XXX needs to work when both -s and -d specified (logical or)
            # XXX needs error checking
            # XXX $7 and $12 are source or destination ports (if any)
            logging.debug("EXTENDED_ACL_RE, line = %r", line)
            logging.debug("wildcard = %r", wildcard)
            src = range_to_net(r.group(3), r.group(4), r.group(5), r.group(6),
                               usewild=wildcard)
            logging.debug("src = %r", src)
            dst_range = r.group(8)
            if dst_range is None:
                dst_range = "any"
            dst = range_to_net(dst_range, r.group(9), r.group(10), r.group(11),
                               usewild=wildcard)
            logging.debug("dst = %r", dst)
        else:
            r = re.match(STANDARD_ACL_RE, line, re.X)
            if r:
                logging.debug("STANDARD_ACL_RE = %r", line)
                # XXX ugly code
                if r.group(4) is None:
                    src = range_to_net(r.group(2), None, r.group(3), "0.0.0.0")
                    logging.debug("biz = %r", src)
                else:
                    src = range_to_net(r.group(2), None,
                                       r.group(3), r.group(4))
                    logging.debug("baz = %r", src)
                dst = iptosubnet("0.0.0.0/0")
                logging.debug("qux = %r", dst)
            else:
                r = re.match(NETWORK_OBJECT_HOST_RE, line, re.X)
                if r:
                    logging.debug("got NETWORK_OBJECT_HOST_RE")
                    src = iptosubnet(r.group(1))
                    dst = iptosubnet("0.0.0.0/0")
                    logging.debug("src = %r", src)
                else:
                    r = re.match(NETWORK_OBJECT_NETWORK_RE, line, re.X)
                    if r:
                        logging.debug("NETWORK_OBJECT_NETWORK_RE, line = %r",
                                      line)
                    else:
                        r = re.search(SUBNET_WITH_MASK_RE, line, re.X)
                        if r:
                            logging.debug("SUBNET_WITH_MASK_RE, line = %r",
                                          line)
                    if r:
                        a1 = r.group(1)
                        a2 = r.group(2)
                        logging.debug("a1 = %r", a1)
                        logging.debug("a2 = %r", a2)
                        sn1 = iptosubnet(a1)
                        sn2 = iptosubnet(a2)
                        logging.debug("sn1 = %r", sn1)
                        logging.debug("sn2 = %r", sn2)
                        nm2 = netmasktoprefix(sn2.ip)
                        if maskof(nm2) != sn2.ip:
                            logging.debug("does not match: %d and %d",
                                          maskof(nm2), sn2.ip)
                            continue
                        logging.debug("nm2 = %r", nm2)
                        src = Subnet(ip=sn1.ip, prefix=nm2)
                        dst = iptosubnet("0.0.0.0/0")
                        logging.debug("src = %s", src)
                    else:
                        r = re.search(SUBNET_RE, line, re.X)
                        if r:
                            logging.debug("GOT SUBNET_RE, line = %r", line)
                            src = iptosubnet(r.group(0))
                            dst = iptosubnet("0.0.0.0/0")
                            logging.debug("src = %r", src)
                        else:
                            logging.debug("NO MATCH = %r", line)
                            last_acl_name = None
                            current_acl_name = None
                            current_acl_line = None
                            continue

        if (match_subnet_prefixrange(src, srcip) and
                match_subnet_prefixrange(dst, dstip)):
            if current_acl_name and (last_acl_name is None
                                     or last_acl_name != current_acl_name):
                assert current_acl_line is not None
                print("%5d %s" % (current_acl_line, current_acl_name))
                last_acl_name = current_acl_name
            print("%5d %s" % (line_num, line))

if __name__ == '__main__':
    main()

# vim: filetype=python et ts=4 wm=0:
